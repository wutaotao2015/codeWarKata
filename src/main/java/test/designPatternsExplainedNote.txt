Design Patterns Explained
    A new perspective on Object-Oriented Design

Preface
    can understand 10 most essential design patterns from this book.

    From object orientation to patterns to true object orientation

        patterns are supposed to be sewn together to solve a problem.

        patterns existed at all levels-analysis, design and implementation.
        And in describing the problem itself.

        design patterns can be derived from some basic strategies and principles.

    From artificial intelligence to patterns to true object orientation

    A note about conventions used in this book
        first person voice
        scanning text
        code fragments
        strategies and principles
        show breadth and give a taste
    feedback
    acknowledgeMent

chapter 1 the Object-Oriented paradigm

    before the object-oriented paradigm: functional decomposition

        functional decomposition can simplify complex problems, and it is so often and naturally used by us
        that we don't consider other possibilities.

        it can't deal with future changes.

    the problem of requirements

        requirements always change!

        the users' view and developers' view and the developing environment are all possible to change.

    Dealing with changes: using functional decomposition

        functional decomposition's code are often low cohision and tight coupling.
        changes to this kind of code result in unexpected side effects and we have to spend a lot of time
        finding the bugs.

    Dealing with changing requirements

        example: let students to go their next class,and graduate students need to do more work than
        undergraduate students.
        shift responsibility

        1. the students are responsible for themselves, the instructor don't need to control everything
        2. the control program can talk to different types of students as if they are the same.
        3. the control promgram don't need to know specific steps students take.

        three perspectives at software development process:
            conceptual
            specification
            implementation
        communicating at conceptual level while performing at implementation level is very powerful.
        controller only knows what is conceptually happening other than what is exactly happening.

    the object-oriented paradigm

        normally,we get object by finding nouns in requirement and get methods by finding verbs.

        An object is best regarded as something with responsibilities.
        abstract classes are more than classes that can't be instantiated, it is a placeholder for
        other classes at the conceptual level.

        encapsulation is more than hiding data, it means any kind of hiding in general.Such as
        the instructor don't know the student type is undergraduate or graduate.

    object-oriented programming in action

        advantages with encapsulation:
            user don't need to worry about implementation
            implementations can be changed without worrying about caller
            the inside of object are unknown to outside objects using its interface

        For change's side effects problem with the above functional decomposition's changing code,
        object can only be changed by calling its own method, its data and implementation detail are
        shielded from other object's change by encapsulation.
        On the other hand, internal changes made to the object are transparent to other objects as well.

    special object methods

        constructor and destructor

    summary

    1. 叙述功能分解中使用的基本方法
        将大问题分解成小问题，逐个解决
    2. 导致需求变更的3个原因
        客户看到成果后认知的改变，开发人员对业务熟悉后的改变，开发环境的改变
    3. 用责任而不是功能来思考意味着什么
        意味着每个对象都是独立负责自己职责的单元
    4. 给出耦合和内聚的定义，什么是紧耦合
        内聚指单个模块内部的操作之间联系的紧密程度
        耦合指不同模块之间联系的紧密程度
        紧耦合指不同模块之间联系过于紧密，任何一个改动影响范围都很大
    5. 对象接口的目的是什么
        对象含有包括自身状态的信息，可以实现相应的行为，同时它需要提供公开接口方便其他对象调用它实现行为
    6. 给出类实例的定义
        类的特定对象
    7. 类是一个对象行为的完整定义，说明了对象的哪3个方面
        对象是类的特殊化，对象的行为可能是不全面的，对象行为的定义都包括在类中
    8. 抽象类的作用是什么
        抽象类代表了一些相关类的共同特性，可以在需要的地方当作其他类的占位符
    9. 对象可能具有的3种可访问性
        public protected private
    10. 给出封装的定义，并举出一个行为封装的例子
        封装指将一块可能发生变化的部分单独划分出去作为独立单元。如一个人上班的方式，坐地铁和开车都可以，这就可以封装成交通方式。
    11. 给出多态的定义，并举出一个多态的例子
        多态指不同的具体对象根据其自身类型实现相同方法的不同行为的能力。如猫和狗都属于动物，动物都会叫，但猫和狗的叫声不同
    12. 观察对象的3种视角是什么
        概念，规约，实现
    阐述题：
    1. 用“模块”来隔离不同区域的代码是应对需求变更的有效方式么？
        不是，模块还是以功能分解的方式来解决问题，不同模块实现不同的功能，但不同模块间处理的实体对象是基本相同的，
        当需求变更时，又需要增加新的模块，重复性高，应按需求寻找合适的实体，需求变更时对实体的功能进行扩展或改动即可
    2. 抽象类被定义成不能实例化的类局限性很大，为什么？更好的定义是什么？
        抽象类在实现层面理解成不能实例化的类作用很小，它主要功能是在概念层面上定义了一组相关类的共同行为，为其他对象的调用提供了
        一个公共的接口。
    3. 行为的封装怎样限制需求变更带来的影响？它又怎样挽救程序员免于无意导致的副作用
        封装的主要作用就是将可能发生变化的部分隔离出去，从而在需求发生变化时只需要改变被封装部分内部的逻辑或行为，外界的调用者无需
        也不会知道封装对象内部的具体行为，从而变化发生时对调用者不会产生影响，同时也免去了可能的副作用。
    4. 接口怎样有助于保护对象不受其他对象变化的影响
        对象由其状态信息和实现行为构成，状态信息都是私有的，行为一般都是公共的，也就是说想要改变一个对象的状态，只有通过调用它的
        方法才能改变，当其他对象发生改变时，它的状态信息改变了，但并没有调用当前对象的行为接口，从而对于当前对象没有影响。
    5. 请从概念视角描述教室
        概念是软件要负责什么，规约是怎么使用软件（接口），实现是如何实现自己的责任
        教室提供了一个可以让多个不同类型学生和老师上课的场所
    观点与应用题
    1. 需求变更是软件开发人员面临的最大挑战之一，请举个例子。
        需求变化可能会导致大量的返工。
    2. 功能分解遇到需求变更有本质的弱点，你同意么，为什么
        功能分解通常会导致一个主程序控制多个子程序，主程序要控制的功能太多，容易产生非常复杂的代码。此时需求变化时经常需要对
        这个模块进行修改代码，而由于代码复杂，耦合性太高，改动非常容易引起意想不到的bug.
    3. 你认为应对需求变更的最佳方法是什么
        以面向对象的思维来建立模型，按各自的职责划分不同的实体，同时尽量预测可能发生变化的部分，将其将封装出去。

chapter 2 the UML - the unified modeling language

    overview
    What is the UML?
        mainly use Interaction Diagram(sequence diagram), class diagrams, state diagrams
    why use the UML?
        for communication, clarity, precision
    the class diagram
        public +
        protected #
        private -

        class name is italicized means it is an abstract one
        using open (unfilled) diamond to show aggregation relationship
        using filled diamond to show composition relationship
        using a dashed line with an arrow to show a 'use' or dependency relationship

        the note in UML
        cardinality: the number of objects contained or be contained

    interaction diagram

        the object instantiation and messages conveyed between them

    summary
        we can use note to clarify
    简答题
    1. is-a和has-a的区别是什么?2种关联关系是什么
        is-a是包含的关系，has-a是拥有的关系。
        “关联”关系是组合与聚合，对应着包含和拥有的关系。
    2. 类图的三部分
        类名，数据成员，方法接口
    3. 重数的定义
        不同对象间的数量关系
    4. 序列图的定义
        不同对象间的交互过程
    阐述题
    1. 给出is-a和2种关联关系的例子
        is-a: 一只猫是一种动物
        组合：一辆自行车有2个轮子
        聚合： 水果盘里有苹果 1:4
    2. 序列图有多少步，多少对象，哪些对象
    3. 对象互相交流时，为什么说发送消息比调用操作好
        因为对象是独立负责自身的单元，发送消息通知对象完成自身的任务，而调用操作还是面向过程的思维，没有转移责任。
    观点与应用题
    一个序列图上应该显示多少步

chapter 3 a problem that cries out for flexible code

    overview
    extracting information from a CAD/CAM system
        expert system are more complex and longer than CAD/CAM system, so the extracting-information
        tool need to be flexible enough for future CAD/CAM system's changes.
    understand the vocabulary
        slot, hole, cutout, special, irregular
        geometry, part, dataset or model, NC machine and NC set(numerically controlled)
    describe the problem
        the features need to be made in right order to make the right part, and this
        order is made by expert system.
    the essential challenges and approaches
        the expert system don't need to know the version of CAD/CAM, and changing CAD's version won't
        need to change the expert system's code.
    summary
        we want to communicate with different implementations in the same way.

chapter 4 A standard object-oriented solution

    overview
    solving with special cases
        each feature has a V1 model and a V2 model
    summary

chapter 5 an introduction to design patterns

    overview
    design patterns arose from architecture and anthropology
        how to design a great backyard
    moving from architectural to software design patterns
    why study design patterns
        reuse solutions
        establish common terminology
        gives a higher-level perspective, avoid dealing with details too early
    other advantages to studying design patterns
        design to interfaces
        favor composition over inheritance
        find what varies and encapsulate it
    summary

chapter 6 the facade pattern

    overview
    introducing the facade pattern
        a new way or a special way to interact with the system
    learning the facade pattern
        presents a new interface for the clients to use the subsystem.
        consequences: simplified the use of the system, but it only contains part of the system, certain
        functionality may be unavailable.
    field notes: the facade pattern
        we can create this easy new interface because we don't need to use all of the functions
        patterns set a general approach,it's blueprints to get started
        the facade can also be used to hide or encapsulate the old system:
            1. track system usage
            2. swap out systems
    relating the facade pattern to the CAD/CAM problem
        for V1Slot, V1Holes using V1 system, we need to use facade to simplify the usage from its complex
        implementation.
    summary
        the facade pattern applies when:
            you don't need all of the functionality of the complex system
            you want to hide or encapsulate the original system
            you want to use the original system and add some new functionality as well
            the cost of writing this new class is less than learning the original system or maintaining it
chapter 7 the adapter pattern
    overview
    introducing the adapter pattern
        create a new interface for a object which does the right thing but has a wrong interface
    learning the adapter pattern
        by containing the needed class in our new class we can implement the polymorphism as we like.
        the adapter provides a wrapper with the desired interface
        consequeces: allows preexisting objects to fit into new system without the limits of its own interfaces.
    field notes: the adapter pattern
        if the existed object don't have all the functionality we need, we can do it in the wrapper class.
        Object adapter pattern
            one object containing another
        class adapter pattern
            with multiple inheritance

        the differences between facade and adapter
            1. they both have preexisting classes
            2. facade don't need to design to specific interface, and adapter must do.
            3. facade don't need to behave polymorphically, while adapter probably do.
            4. facade need to get a simpler interface, and adapter don't need to.

        bottom line: A facade simplifies an interface while an adapter converts the interface(new) into
        a preexisting interface(old).
    relating the adapter pattern to the CAD/CAM problem
        for V2 system, many features don't have the needed interfaces, so we can use adapter to get
        the interface we needed through the newly created OOGFeature object.
    summary
        adapter pattern is implemented by creating a new class with desired interface and wrapped the
        original class to do what we actually need to do.

chapter 8 expanding our horizons

    overview
    objects: the traditional view and the new view
        an object is an entity that has responsibilities
    encapsulation:
        encapsulation should be thought as any kind of hiding
    find what is varying and encapsulate it

