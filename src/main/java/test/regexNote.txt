
chapter 1  入门
    1. 以文件名类比
    2. 以语言做类比
        元字符和普通字符
    3. 检索文本文件 Egrep
    4. Egrep
        grep为(global search regular expression and print out the line)为文本搜索工具
        egrep用于在文件内查找指定的字符串，效果相当于grep -E，目前直接调用egrep已废弃？用grep -E
        grep是使用basic regular expression,egrep使用extended regular expression,后者更规范

        元字符
            脱字符^: 字符串的开始caret(脱字符，插入记号（即快捷键中的光标))
            美元符号$： 字符串的结束
            以字符来理解正则表达式，
            如^cat表示的是以字符c开始的一行，后面紧接a和t字符
            即它们匹配的都是一个位置。
        字符组
            匹配若干字符之一
            <H[123456]>匹配<H1>,<H2>等html标签
            [0-9A-Z_!.?]匹配一个数字或大写字母，_或!或.或？,
            即在字符组[]中特殊字符只有连字符-(连字符在开头，紧接[时不是元字符,不是范围,为普通字符)
            ^cat$ 匹配只有cat的一行，不含多余字符
            ^$ 匹配一个空行 无任何字符，也不含空白字符
            ^ 匹配一行的开始，所有行都满足条件，无意义

        排除型字符组 （需要匹配一个字符，包括空白字符）
            [^1-6] 匹配除了1到6之外的任何字符，脱字符^只有紧跟[后才是元字符
            q[^u]无法匹配到Iraq
            是因为Egrep自动把换行符去掉了，若换行符没有去除，它仍是可以匹配到的
            这里说明的是排除型字符组也需要匹配一个字符
        用点号匹配任意字符 （需要匹配一个字符，包括空白字符）
            3344.55 可以匹配到 3344 55
            但33.44.55 无法匹配到 3344 55
            即点号也需要匹配到一个字符，无字符是无法匹配到的，空白字符也是一个字符
            33[-./]44[-./]55更精确，但读写消耗较大，33.44.55不够精确，但可读性和可写性强，
            在不可能匹配到非期望结果的情况下，33.44.55更佳。
            所以清楚了解目标的文本对于正确编写正则表达式是非常重要的。
        多选结构
            匹配任意子表达式
                | 表示或者(它是贪婪匹配的)，把不同的子表达式组合成一个总表达式，这个总表达式可以匹配任意一个子表达式
                子表达式称为“多选分支”
                gr[ea]y grey|gray gr(e|a)y都可以正确匹配，
                而若去掉括号gre|ay或者gr[a|e]y都不可以匹配到grey或gray的字符串
                一个字符组只能匹配目标文本中的单个字符，而多选结构可以匹配完整的正则表达式

                如(grey|gray)|(grey|gray)可以匹配到greygray和greygrey。

                ^From|Subject|Date: 和 ^(From|Subject|Date): 匹配的结果大不相同
                如果希望每个多选分支前都有脱元符和其后有冒号，需要用括号来限制这些多选分支
                egrep '^(From|Subject|Date):' test.txt
                该命令会打印出以From:或Subject:或Date:开头的一行文本
        忽略大小写
            正则表达式本身没有提供这样的功能，但egrep工具提供了，可以使用-i参数使其在匹配时忽略大小写
            grep -Ei '^(From|Subject|Date): ' test.txt
            这样也可以匹配到FROM: 了。
        单词分界符
            部分egrep支持元字符序列，即\<和\>,它与\b功能相同？
            这里说的单词的开始和结束具体指的是字母数字符号的开始和结束，除了常见的空格分隔，
            dang-wer开始于d,结束于g,再开始于w,结束于r
            we'll开始于w,结束于e,开始于l,结束于l
            $199开始于1,结束于9
        可选项元素
            colou?r这个正则表达式中？只作用于之前紧邻的元素
            4th|4可以转化为4(th)?
            此时？的作用范围扩大到整个括号了
        其他量词： 重复出现
            +代表之前紧邻的元素出现一次或多次
            *代表之前紧邻的元素出现任意多次或者不出现
            即尽可能匹配多的次数
            ' ?'能够匹配一个空格， ' *'能匹配任意多个空格
            如匹配标签的<H[1-6] *>可以匹配<H1>,<H2   >
            <HR +SIZE *= *[0-9]+ *>看起来让人迷惑，是因为元字符*和+作用的是空格，即在正则表达式中空格也是普通字符之一
            每个量词都规定了自己匹配的上下限，有的下限为0或1，有的上限为1或无穷大
        规定重现次数的范围： 区间
            如[a-zA-Z]{1,5}
        括号及反向引用
            括号用途
            1. 限制多选项的范围|
            2. 若干字符组合为一个单元，受量词？或*号等的限制
            3. 记住包含的子表达式匹配的文本。

            反向引用： 括号记住了里面匹配的文本（不是模式），后面可以通过\1,\2等来重复该文本

            如重复单词the   the可以用\<([a-zA-Z]+) +\1\>来匹配
            \1,\2,\3表示第1，2，3组括号记住的文本内容，其顺序是按左括号从左到右的顺序进行的

        神奇的转义
            slash 斜线 /
            backslash 反斜线 \   需要匹配元字符本身时可以进行转义
            此时反斜线称为转义符（escape)
            大多数语言和工具支持字符组内部的转义，不过大多数egrep命令不支持，在字符组内部\是普通字符
        基础知识拓展
            语言的差异
                每种语言提供了自己的改进，形成了自己的流派
            正则表达式的目标
            更多的例子
                变量名
                    即标识符，包含字母，数字，下划线，但不能以数字开头,不能超过32位
                    [a-zA-z_][a-zA-Z_0-9]{0，31}
                引号内的字符串
                    "[^"]*"
                美元金额 可能有小数
                    $[0-9]+(\.[0-9][0-9])?
                http/HTML url
                    \<http://[-a-z0-9_.:]+/[-a-z0-9_:@&?=+,.!/~*%$]*\.html?\>
                    或者更简单
                    \<http://[^ ]*\.html?\>
                HTML tag
                    <.*>可以匹配多个标签，如<p>short</p>
                表示时刻的文字
                    12小时制是从12，1，2，...,10, 11计数，12小时制没有数字0开头，它是从12开始
                    12：00am 即半夜0点，12：00pm是中午12点
                    即（1[012]|[1-9]):[0-5][0-9] (am|pm)
                    24小时制（0?[0-9]|1[0-9]|2[0-3]):[0-5][0-9]
                    合并前2个多选分支，变为([01]?[0-9]|2[0-3]):[0-5][0-9]
                    根据书中匹配的阴影图可以有另外一种写法 ([012]?[0-3]|[01]?[4-9])

        正则表达式术语汇总
            正则 regex
            匹配 matching
            元字符 metacharacter
                只有在字符组外部且在未转义的情况下，*才是元字符，\*中*被转义了，而\\*没有
            流派 flavor
            子表达式 subexpression
                通常是括号内的部分，也可以指|分开的部分，也指单个字符
                H[1-6] *中1-6不是子表达式，因为它属于字符组，不可分割，[1-6]是子表达式
                量词（*，+，？）作用的对象就是它之前紧邻的子表达式，或者是用括号括起来的子表达式
            字符 character
            改进现状
                正则表达式的使用
                正则表达式的特性
                正则表达式的工作原理
            总结
                元字符分类
                    匹配单个字符 . [...] [^...] \char
                    提供计数功能的元字符 ？ * + {min, max}
                    匹配位置的元字符 ^ $ \< \>
                    其他元字符 | （...) \1 \2
chapter 2 入门示例拓展
    关于这些例子
    Perl简单入门
        变量以$开头，存储数值或文本
        变量可以出现在字符串中，会被其实际值取代,可以用Perl -w test.txt命令执行脚本程序（-w参数可以检查程序是否规范）
    使用正则表达式匹配文本
        $test =~ m/^[0-9]+$/
        若测试文本test中只包含数字，则该表达式值为true
    向更实用的程序前进
        $c =~ m/^[-+]?[0-9]+(\.[0-9]*)?$/   可以匹配负数和小数
    成功匹配的副作用
        正则表达式中的在匹配时，\1反向引用了之前匹配的文本，匹配成功后接下来的程序可以用$1引用相同的文本
        $c =~ m/^([+-]?[0-9]+)([CF])$/
        其中的括号既没有改变量词的作用范围，也没有改变|的意义，即加括号不影响匹配的文本，它是括号的第3种用法，为捕获型括号。
        代码示例：
        if($input =~ m/^([+-]?[0-9]+)([CF])$/){
	        $num = $1;
	        $type = $2;
	        if ($type eq "C") {
    错综复杂的正则表达式
        允许输入浮点数时，正则表达式变为 ^([-+]?[0-9]+(\.[0-9]*)?)[ \t]*([CF])$
        此时程序中区分摄氏度和华氏度的C和F的保存变量由$2变为$3
        如果不想更改程序中的$2,即这个小数部分程序中不需要用到的话，可以使用非捕获型括号（?:...）
        即只分组不捕获
        此时正则表达式变为^([-+]?[0-9]+(?:\.[0-9]*)?)[ \t]*([CF])$
        这时CF保存的变量（Perl中）即为$2,小数部分(?:)不影响捕获计数
        非捕获型括号可以提高匹配效率，使得括号区分度高，但提高了阅读难度，可以根据具体情况选择是否使用

        [ \t]*和（ *|\t*)的区别
            后者不能匹配空格和\t的混合，只能匹配多个空格或者多个制表符
            前者*限制的是字符组[ \t],所以每个字符都可以进行选择，即支持匹配两者混合的情况

    一点题外话——数量丰富的元字符

        字符串的元字符和正则表达式的元字符是不同的，它们有的是相同的意义，如制表符\t
        shell中的空格符，$, *, ?等也是其自身的元字符，需要与正则表达式区分开
        即有的时候需要在不同层级上同时使用元字符进行交互

        用\s匹配所有空白
            即相比[ \t]*,使用\s是更好的选择
            \s表示所有空白字符的字符组，包括了空格符，制表符，换行符，回车符
            用m/.../i可以匹配大小写，其他还有/g表示全局匹配
            程序中的$type eq "C"需要修改为 $type =~ m/c/i同时匹配大小写的c
            所以正则表达式的变化也会影响到程序的其他部分
        暂停片刻
            Perl的正则表达式中的元字符比egrep更多，java, python类似于Perl
            Perl和其他流派的正则表达式提供了很多简记法shorthands:
                \t \n \r \s \S
                \w = [a-zA-Z0-9] \w+即一个单词
                \W = [^a-zA-Z0-9]
                \d = [0-9]
                \D = [^0-9]
            匹配成功后，Perl可以用$1, $2等变量保存对应括号内子表达式匹配到的文本，
            使用这些变量就可以用正则表达式从字符串中提取我们所需要的信息
    使用正则表达式修改文本
        使用$var =~ s/.../.../ 即如果正则表达式能够匹配$var中的某段文本，就将这段匹配上的文本替换为后面的文本
        如
         $test = "HelloTest666Test";
         $test =~ s/Test\d+Test/999/;
         print "$test\n"
        输出结果为Hello999

        $var =~ s/\bJeff\b/Jeff/i
        其中/i限制的是对\bJeff\b中的Jeff的大小写情况，即不论Jeff的大小写情况如何，它会被统一替换为Jeff

        例子：公函生成程序
        s/regex/replacement/中的用于替换的replacement其实是perl中的字符串，
        可以像上面的程序那样引用变量
        \g全局替换修饰符，即第一次替换完成后继续搜索更多匹配文本，进行更多替换

        例子：修整股票价格
            23.423000000234小数点后第3位若不为0就保留3位，否则就保留2位，
            思路即对整个数字进行匹配，将需要保留的部分放入括号内，替换时利用括号捕获进行替换
            第3位利用[1-9]?)\d*来进行取舍
            $price =~ s/(\.\d\d[1-9]?)\d*/$1/
            小数点后面的\d*被正则表达式匹配上了，用$1替换时会被删除
        自动的编辑操作
            perl -p -i -e 's/X/wutaotao/g' 2test.txt
            -p 对每行进行查找和替换 和-n相似，循环
            -i 将替换结果写入文件 edit files in place
            -e 后面接的就是程序本身，省略了文件 one line program
            即通过一行命令可以替换多个文件中的多个字符
        处理邮件的小工具
            $line = <> 这条语句相当于getLine(),读入一行数据,为空时返回false
            如上面匹配html标签一样，<.*>中会匹配尽可能多的任意字符，使用时应注意前后端的表达式匹配的重复性问题
            针对发送地址的提取，如From: taotao@qq.com (wutaotao)需要提取其中的邮件地址和后面括号中的姓名
            ^From: (\S+) \(([^()]*)\)
            其中\S表示非空白字符，[^()]表示非括号的排除型字符组，值得注意的是在字符组内部括号不是元字符，不需要转义

            perl中while的break为关键字last
            在每行开头增加|> 可以用正则表达式
            while($line = < >) {
                   $line =~ s/^/|> /;
                   print $line;
            }
            由此可以得到类似的有效例子：
                perl -p -i -e 's/^/**/' 3Test.txt 开头增加2个星
                perl -p -i -e 's/^\*+(.*)$/$1/' 3Test.txt 去掉开头增加的星
        用环视功能为数值添加逗号（分位符）
            环视不匹配字符，只匹配位置，同^,$,\b相似
            顺序环视
                顺序查看文本（向右找），如果匹配子表达式，则匹配成功
                (?=...)
            逆序环视
                逆序查看文本（向左找），同样不消耗字符
            环视不会消耗字符（占用）
                环视可以精确定位到需要匹配的位置
                (?=Jeffery)Jeff与Jeff(?=ery)是等价的，最终匹配点位置停在了Jeffery的ff后。
                即前面的环视匹配成功后可以定位到Jeffery的前方，再进行匹配Jeff字符
                若环视匹配不成功，整个正则表达式也不会匹配成功
                如Jeff(?=Jeffery)就不能匹配上

                (?=) (?<=) (?:)都是有自己的"开括号"--(?, 没有普通括号的捕获功能。
            更多的环视例子
                如将see Jeffs book中Jeffs改为Jeff's
                应用环视的终极例子为
                    perl -p -i -e "s/(?<=\bJeff)(?=s\b)/'/g" 4test.txt
                    这个例子说明了（？=）是从目标位置的右边开始寻找，（?<=)是目标位置的左边开始寻找，
                    即一个是右边，一个是左边，具体的匹配过程仍然是从左到右的
                    两个位置限制都符合的情况下，该位置就被确定了
                    perl -p -i -e "s/(?=s\b)(?<=\bJeff)/'/g" 4test.txt
                    环视结构的顺序是无所谓的，因为它们都未消耗字符，同时满足就可以。
                    （最后加\i有问题）
            回到逗号的例子
                $popu = 12345678;
                $pop =~ s/(?<=\d)(?=(\d\d\d)+$)/,/g;
                print $pop;
                程序中的$保证了逗号后面的数字个数是3的倍数, 要插入逗号的位置前至少有一个数字
                其中（\d\d\d)是捕获型括号，会保存值到$1中，可以替换为(?:\d\d\d),不过可读性降低了
            单词分界符和否定环视
               $popu = "12345678 is growing"时$无法使用，因为数字后面还有内容，不是行尾
               所以可以用单词分界符\b代替
               否定环视
               正向肯定环视(positive lookahead) (?=)
               反向肯定环视(positive lookbehind) (?<=)
               正向否定环视(negative lookahead) (?!)
               反向否定环视(negative lookbehind) (?<!)
               所以单词分界符\b = (?<=\w)(?!\w)|(?<!\w)(?=\w)
               所以上述例子应写为$popu =~ s/(?<=\d)(?=(\d\d\d)+(?!\d))/,/g;
               \D代表某个不是数字的字符，它和(?!\d)不同,后者可以匹配空，前者必须要有一个字符
               不通过逆序环视添加逗号
               有些语言不支持逆序查找，所以可以利用捕获型括号来实现
               $popu =~ s/(\d)(?=(\d\d\d)+(?!\d))/$1,/g
               但是s/(\d)((\d\d\d)+\b)无法实现功能，它只有开始的一个逗号，即12,345678
               原因是因为\g的全局替换是从上一次匹配完成后的位置开始的，
               正向环视不消耗字符，所以一个表达式在匹配时可以加入多个逗号
               而((\d\d\d)+\b)不是匹配位置，匹配第一个逗号时即消耗了所有字符，\g无法起到预想的作用
               想使用该表达式，只有在程序中循环调用该表达式才可以，每次加入一个逗号直到无法匹配为止
        Text-to-Html转换
           处理特殊字符
            因为html中&,<,>是特殊字符，所以文本中原有的这几个字符需要进行转换成html编码才能正确显示
            $text =~ s/&/&amp;/g;
            $text =~ s/</&lt;/g;
            $text =~ s/>/&gt;/g;
           分隔段落
            perl中用undef $/; $text=<>;将多行的文本读取为一行字符串，其中每个逻辑行用\n或\r\n分割，
            由于^和$实际表示的是字符串的开头和结尾,不能按需提取每个逻辑行
            所以可以使用"增强的行锚点",即$text =~ s/^$/<p>/mg;增加了/m参数
            考虑到包括空白字符的行可以用^ *$,也可以用^\s*$,因为\s也可以匹配换行符，
            所以当有多个连续空白行时,s/^\s*$/<p>/mg只会出现一个<p>.
           Email地址转化成超链接
            $text =~ s/\b(username\@hostname)\b/<a href="mailto:$1">$1<\/a>/g;
            其中@需要转义，/a中的/需要和单词分界符区分开来，故也需要转义，perl也可以使用单词分界符{}
           用户名和主机名
            用户名可以包含字母，数字，点号和连字符，但不能以点号和连字符开头，
            所以它可以写为\w[-.\w]*
            主机名例子为www.oracle.com,.之间需要字符存在并且末尾com等需要是一些固定值
            所以它可以写为(\w+(\.\w+)*)\.(com|edu|info)
            \w可能匹配一些非ascii码字符和下划线，所以不应该用\w,应为[-a-z0-9]
            为了美化代码可以用\x修饰符，它可以忽略正则表达式中的空白符和以#号开头的注释
           综合起来
            注意只有分隔段落用到了\m，因为它用到了^和$,其他正则表达式使用了没有影响
           将http url转化为链接
               $text =~ s{
                   \b
                    # 保存url到$1中
                    (
                      http:// hostname
                      (/path)?
                    )
               }{<a href="$1"</a>}gix;
            其中单词分隔符为{},所以/a不需要转义
            path后没有\b,因为url后一般是标点符号，用逆序环视来确定标点符号前的内容能匹配到path中
            即[...]*(?<![,.!?])
           构建正则表达式库
            Email和url中的主机名hostname使用相同的正则表达式，可以使用变量将它提取出来
            即$HostnameRegex = qr/.../i;
            qr操作符能够产生一个regex对象,其他语言也提供了创建正则表达式对象的方法，比如java
           为什么$和@需要转义
            perl中字符组内部$不能正确匹配$本身，需要进行转义
            同样perl用@表示数组名，需要转义才能匹配本身
        回到单词重复问题
            $/ = ".\n"指<>返回一段文本(句号和换行符的结合),不再是单行文本
            找到重复单词用转义后的高亮文本替换重复出现的单词(这里假设原文中没有ascii转义符\e)
            转义符加好后，去除没有转义符\e的逻辑行，以上查找重复是对整个段落进行查找，这里是对
            逻辑行处理，加上\m修饰符。
            同样的，对每个逻辑行开头加上文件名($AGRV)，也是使用\m
        更深入一点: 运算符，函数和对象
            java对正则表达式的处理不像perl一样是基础级别的，它用多个包来实现
            java要求正则表达式先用字符串的形式得到一个编译版本，其中正则表达式自带的\需要转义，如\\b
            Pattern regex1 = Pattern.compile("\\b...", Pattern.CASE_INSENSITIVE);
            Pattern regex2 = Pattern.compile("^([^\\n]+)", Pattern.MULTILINE); // 表示perl中的\m修饰符
            regex1.matcher(text).replaceAll(replace1);
            regex3.matcher(text).replaceAll(args[i] + ": $1");
            即与perl的$test =~ s/../../gix中对文本应用正则表达式不同，
            java是用编译后的正则表达式对象来应用到文本中。

chapter 3 正则表达式的特性和流派概览

    1. 支持的元字符
    2. 正则表达式与语言或工具的交互方式
    3. 正则表达式引擎如何将表达式应用到文本

    正则表达式和汽车
    发展历程
        grep
        egrep
        perl 书中使用版本5.8.8 本地是5.26.2
        其中grep支持功能更少，应使用egrep,不支持非捕获型括号,单词分界符为\<\>,
        (本机用2.5.1free bsd, 经测试支持非捕获型括号,也支持\b,\<\>也支持。。。)
    正则表达式的注意事项和处理方式
        1. 句法规则 定义正则表达式，如egrep中用命令行参数引入正则表达式
        2. 对结果进行操作 如egrep显示匹配的行，包括匹配，替换，查找

        集成式处理
            $text =~ m/^Subject: (.*)/i; $subject = $1;
        程序式处理和面向对象式处理
            java中的正则处理
                import java.util.regex.*;
                Pattern regex = Pattern.compile("^Subject (.*)", Pattern.CASE_INSENSITIVE);
                Matcher m = regex.matcher(line);
                if(m.find()) {
                    subject = m.group(1);
                }
                函数式处理：Pattern.matches("\\s*", line),java会在正则表达式两边自动加上^和$
                简化了函数调用，但每次调用都会重新编译正则表达式。
            VB和.net     和java类似
            PHP     纯函数式
            if(preg_match('/^Subject: (.*)/i', $line, $matches)) {
                $Subject = $matches[1];
            }
            Python   和java类似
            差异从何而来
                开发人员的水平和思维
            查找和替换
                perl中$text =~ s{regex}{replacement}igx;查找和替换都是在目标变量text中进行的
                其他语言是在目标文本副本上进行的，需要修改原变量需要将替换结果回传。

                java中的查找和替换
                    Pattern r = Pattern.compile("
                        # 正则表达式开始            \n"+
                        "...", Pattern.CASE_INSENSITIVE|Pattern.COMMENTS);
                    Matcher m = r.matcher(text);
                    text = m.replaceAll("<a href=\"mailTo:$1\">$1</a>");
                    其中包括换行符一是格式整齐，另一方面是#注释需要以换行符结束。
                    即perl使用/g,/i,/x来表示不同的特殊条件，java用不同的函数(replaceAll)和不同标志位来限制

                vb.net中的查找和替换 和java类似
                PHP中的查找和替换 和perl类似
                其他语言中的查找和替换
                    awk,TCL,GNU Emacs
            字符串，字符编码和匹配模式
                作为正则表达式的字符串
                    即需要注意表示正则表达式的字符串处理结束后，正则引擎接受到的正则表达式是什么？
                    java中可以使用
                        Pattern regex = Pattern.compile("\\w");
                        System.out.println(regex.pattern());
                    查看真正被处理的正则表达式是什么。
                    java
                    VB.NET
                    C#
                    PHP
                    Python
                    TCL
                    Perl
                字符编码
                    编码的支持程度
                    Unicode 通常用一个4位的16进制数来表示一个字符
                    字符，还是组合字符序列
                        在unicode的编辑器中，一个带音调的字符由2个代码点组成
                    用多个代码点表示同一个字符
                        unicode中可以用2个代码点表示一个带音调的字符，也可以用一个代码点表示
                        此时，不同的字符无法从外观上区分开，需要检查生成的文本。
                    Unicode3.1后的代码点
                    Unicode中的行终止符
                    正则模式和匹配模式
                        不区分大小写的匹配模式
                            不是所有字符都有大小写形式，大小写也不一定是1对1的情况（如希腊字母）
                        宽松排列和注释模式
                            此模式会忽略字符组外部的空白字符
                            但java.util.regex中不都是忽略，而是作为一个无意义的元字符
                            如\12 3会当作3在\12后，而不是忽略空白符后的\123
                        点号通配模式
                            即.*,它常用来匹配本行中的其他内容
                        不幸的命名
                            /s表示单行文本模式，即single-line mode,但它与^和$没有关系
                            /s表示的是.号不受限制，可以匹配任何字符
                        增强的行锚点模式（也叫多行文本模式）
                            如上面的例子所示，此模式下^和$可以匹配字符串内部的换行符
                            单行模式和多行模式其实没有关系
                            单行模式改变了点号的匹配方式(点号默认不能匹配换行符)，换行符从需要处理变为不需要处理
                            (即点号可以匹配换行符了)，即不换行
                            多行模式改变了^和$号的匹配方式，换行符从不需要处理变为需要处理，即多逻辑行
                        文字文本模式
                            该模式不识别任何正则表达式元字符，即匹配具体字符串
                    常用的元字符和特性
                        字符表示法
                            八进制转义
                            十六进制转义
                            控制字符：\cchar
                        字符组及相关结构
                            点号一般是匹配换行符之外的任意字符，点号通配模式可以改变这一规则
                            Unicode属性
                        锚点及其他零长度断言
                            即位置的匹配
                            ^和\A
                            $，\Z, \z
                            \G: java.util.regex包和Perl是匹配上一次匹配的结束位置

                                \G指向的是目标字符串的位置，可以用多个正则表达式去匹配同一个目标

                                一般匹配失败，\G的匹配会回到字符串的起始位置，可以用perl的\c修饰符
                                使它匹配失败时不会重新设定，从而可以指定某个位置开始不断匹配

                                \G的属性可以用与正则表达式无关的结构维护与修改
                        单词分界符
                            \b, \B, \<, \>
                            顺序环视和逆序环视
                                perl和python中逆序环视只能匹配固定长度的文本
                                如(?<!books?)匹配长度不确定，会报错
                                可以重写为(?<!book)(?<!books),这里用到了集合并集

                                java的regex包支持变长，(?<!books?)可以直接使用,但长度不能无限
                                如(?<!^\w+:)会报错
                                .net可以支持无限长度
                        注释和模式修饰符
                            模式修饰符
                                如(?!)和(?-i),前者表示开始不区分大小写，后者表示停止该功能。
                                一般(?!)只作用在括号内部，此时可以去掉(?-i)。如<B>(?:(?!)very)</B>.
                            模式作用范围
                                如(?i:...),此时前面的例子可以化简为<B>(?i:very)</B>.
                            文本文字范围
                                \Q...\E
                        分组，捕获，条件判断和控制
                            捕获/分组括号: (...)和\1,\2
                            非捕获型括号(?:...)
                            命名捕获(?<Name>...), python, php, .net都支持
                            固化分组: (?>...)
                                即一旦括号内的子表达式匹配之后，匹配的内容就固定下来了
                                如i.*！可以匹配iHello!，但i(?>.*)!就无法匹配iHello!，因为*不会交还一开始匹配的！,
                                从而导致匹配失败。
                            多选结构： ...|...|...  大多数流派允许出现空的多选分支
                            条件判断：(?if then |else)
                                if部分测试为真，则尝试then部分，否则尝试else部分(else部分可省略)
                                测试对捕获型括号的特殊引用
                                    (x)?<y>(?(1)z)
                                    (?(1)z)测试前面的(x)?是否参与了匹配，
                                    参与匹配不等于匹配到了具体的文本，匹配到空也算参与了匹配
                                用环视做测试
                                    环视能匹配返回true,否则返回false.
                                    如(?(?<=Num:)\d+|\w+)它会在Num:后的位置上匹配\d+,其他位置匹配\w+
                                其他测试条件
                                    Perl提供了一种复杂的if测试条件，可以使用任意Perl代码
                            匹配优先量词
                                *,+,?,{num, num} 匹配优先，即尽可能多的匹配，贪婪
                                X{0，0}没有意义，表示不需要匹配，应使用否定性环视
                            忽略优先量词
                                *?,+?,??,{num,num}? 忽略优先，即尽可能少的匹配
                            占有优先量词
                                *+,++,?+,{num,num}+ 与固化分组相同，一旦匹配了不会交还
                    高级话题引导

chapter 4 表达式的匹配原理

    发动引擎
    正则引擎的分类
        DFA              awk, egrep, mysql等
        传统型NFA        java, grep, perl, php, python, ruby等
        POSIX NFA        mawk等
        可以通过2个表达式例子来判断引擎类型

    匹配的基础

        规则1: 优先选择最左端的匹配结果

            从第一个字符前的位置开始，每轮尝试都要遍历正则表达式的所有可能
            如fat|cat|belly|your匹配文本The dragging belly indicates your cat is too fat.
            从左到右尝试正则表达式的所有可能，所以匹配结果应是belly.

            "传动装置和驱动过程"
            驱动装置的主要功能: 驱动

            引擎的构造
                文字文本
                    该字符是否与当前尝试的字符相同
                字符组，点号，Unicode属性及其他
                捕获型括号
                    用于捕获文本，不影响匹配过程
                锚点
                    如^,$,\z,(?<=\d)
                非“电动”的括号，反向引用和忽略优先量词
                    即捕获型括号，\1,$1,忽略优先量词的特性只对NFA引擎生效，对DFA是无效的

        规则2: 标准量词是匹配优先的

            即?,*,+,{min,max}都是匹配优先的(greedy)
            邮件主题 用(.*)获取主题
            过度的优先匹配

                如^.*([0-9][0-9])进行匹配时，需要将前面匹配的部分交还最后的2个字符以匹配最后的2个数字
                如匹配文本about24charachterslong时，.*一开始匹配了整个字符串，后面一直交还直到24能满足要求，
                即得到匹配文本about24

            先来先服务

                若^.*([0-9]+)匹配about2003时括号会捕获到什么？
                因为最后交还的3能够满足[0-9]+的要求，.*无需再交还字符，所有括号捕获的是3.

            深入细节
                交还特性的真相是由引擎的类型决定的，是DFA还是NFA.

    表达式主导与文本主导

        NFA: 表达式主导 regex-directed

            如to(nite|knight|night)的例子，表达式会尝试所有可能，从nite到knight，直到最后的night能够匹配
            匹配过程由表达式主导

        DFA: 文本主导 text-directed

            如to(nite|knight|night)的例子，从文本tonight出发，当匹配到toni时，只剩下nite和night2种可能，knight已经被排除了
            即匹配过程由文本决定

        第一想法：比较NFA和DFA

            (Nondeterministic finite automaton)
            NFA可能会对同一段文本进行不同部分的重复检测，甚至匹配后会满足后面的匹配会再一次应用前面的匹配，
            即不到表达式最后，无法知道全局匹配是否成功。It's not over until the fat lady sings.

            (Deterministic finite automaton)
            DFA是确定型的，每个文本字符只检查一次。

            用户需要面对的结果

                因为NFA表达式主导的特性，不同写法的优劣不同
                DFA因为同时记录所有可能，所以不同的写法没有区别

                DFA特征：
                    1. DFA匹配很迅速
                    2. DFA匹配很一致
                    3. 谈论DFA很麻烦

                NFA最重要的特性：回溯

        回溯 backtracking

            即在2种可能之间(量词和多选结构)需要选择一种，当一种可能失败之后，正则表达式需要回溯
            到原来做出选择的地方，直到匹配成功或处理完所有可能。

            真实世界中的例子：面包屑
                即在每个选择处留下面包屑，留下印记

                一个简单的例子
                    to(nite|knight|night)匹配文本hot tonic tonight
                    开始的to匹配到了tonic，然后匹配多选结构，(失败回溯尝试)所有分支都失败后宣告了tonic位置的匹配失败，
                    传动装置传到tonight，最终能够匹配

            回溯的2个要点

                1. 面对众多选择时，哪个分支应首先选择
                    在进行尝试和跳过尝试之间，匹配优先量词会进行尝试，忽略优先量词会跳过尝试
                2. 进行回溯时，应选择哪个保存的状态
                    明显的，距离当前最近的存储选项即是本地失败回溯使用的，即LIFO（last in first out)，和栈相同

                备用状态 Saved State

                    那些保存的状态称为备用状态
                    该状态保存了2个位置：正则表达式中新分支的位置，以及文本字符串作出选择的位置
                    如正则表达式ab?c匹配文本abc
                    在匹配a后NFA针对b?记录了一个备用状态: 表达式ab?#c和文本a#bc
                    这里回溯未进行，直接成功;

                    若匹配文本ac,则回溯到该备份状态处，c匹配成功，最终匹配成功。

                    若ab?c匹配文本abX，进行尝试b时，c无法匹配X,回溯后，
                    c不匹配文本中的b,故此证明从#abc位置开始的匹配全部失败了，
                    此时传动装置从a#bc位置开始匹配表达式，b不匹配a,立即失败；同理直到最后的位置，
                    整个表达式全部失败。


                    忽略优先的匹配

                        表达式ab??c匹配文本abc时，由于是忽略优先，所以它保存的备用状态是: 表达式的a#bc和文本的a#bc
                        忽略优先尝试的c不匹配文本的b,回溯后b匹配b,c匹配c,即匹配成功。

                回溯与匹配优先

                    +号和*号的回溯
                    [0-9]+匹配文本a 1234 num中，因为+必须匹配一次，所以备用状态不包括a #1234 num;
                    问用[0-9]*匹配文本a 1234 num,备用状态是否包括a #1234 num?
                    答案是不包括！因为[0-9]*可以匹配任意内容，表达式直接在#a 1234 num开始位置处匹配完成并结束，
                    没有匹配a以及后面的数字。
                    如果是表达式[0-9]* num匹配文本a 1234 num，则为了匹配后面的 num,状态a #1234 num是会出现在备用状态中的

                重新审视更完整的例子

                    还是表达式^.*([0-9][0-9])匹配文本CA 9876 USA，
                    在匹配过程中保留了多个备用状态，根据需要进行回溯
                    1. 回溯不仅回复了表达式和文本中的位置，对于括号捕获的文本内容也需要维护，所以这种捕获也很影响匹配效率
                    2. 匹配优先量词不受后面元素影响，即^.*([0-9]+)只能匹配一位数字一样

            关于匹配优先和回溯的更多例子

                匹配优先的问题
                    表达式".*"匹配文本"mike" is a "good" man.
                    结果是匹配到"mike" is a "good"部分,因为匹配优先原则
                    用"[^"]*"表达式即可匹配到"mike",即用[^"]替换点号即可。
                    又因为点号不能替换换行符，而[^"]可以，所以如果不想匹配换行符，即匹配部分到换行符也截止的话，
                    可以用[^"\n]替代点号。
                多字符"引文"
                    如果将""替换成HTML标签，需要匹配<B>very</B>标签中的内容，此时排除性字符组因为内部排除的
                    都是一个个的单个字符，无法对</B>的字符组合进行限制。
                使用忽略优先量词
                    针对上面的问题，使用表达式<B>.*?</B>可以初步解决，
                    因为它是忽略优先，点号匹配一个字符后会检查是否后面的字符能否匹配</B>，若能匹配结束，
                    若不能则点号继续匹配下个字符，继续检查后面的字符，直到匹配成功</B>为止或匹配失败。
                    但它也可能匹配到<B>very<B>a</B>的文本。
                    为了解决这个问题，想匹配到需要的<B>a</B>,可以使用否定环视功能，
                    即<B>((?!</?B>).)*</B>,它会从very开始匹配，到<B>a时会失败，直到驱动器从<B>a开始为止。

                    (如果使用逆序环视(?<!</?B>)替换顺序环视，perl会报错variable length。。。
                    因为perl和python的逆序环视只支持固定长度,
                    但逆序本身是错误的，即尝试到需要匹配的文本时，逆序要求前面不是<B>?,
                    这本身即导致了匹配失败，这样就会永远匹配失败，没有符合要求的文本。
                    <B>后面匹配一个前面不是<B>的点号字符?,这个位置失败后传动装置向后走就没有符合条件的文本了)

            匹配优先和忽略优先都期望获得匹配

                对于之前提过的保留2位或3位(第3位非0)小数的例子，最后表达式为
                    $data =~ s/(\.\d\d[1-9]?)\d*/$1/;
                这个表达式是正确的，但是对于文本1.23和2.345来说，替换相当于白费功夫，有没有更有效率的方法，
                使得对这样的例子不去替换？
                即我们的目的是需要表达式对于这2个例子匹配失败。

                若\d*改为\d+,1.23匹配失败，因为\d+没有匹配到，但是对于2.345来说，[1-9]?匹配优先
                会匹配到5，发现\d+不匹配后，进行回溯，此时$1匹配34，\d+匹配5，整体匹配成功，
                从而导致2.345被替换为2.34,从而错误。
                [1-9]?变为[1-9]??忽略优先，结果一样，不进行回溯，直接匹配成功，仍是替换为2.34.

            匹配优先、忽略优先和回溯的要旨

                即无论是匹配优先还是忽略优先，它们虽然测试的路径不同，但一次尝试失败后，都会
                进行回溯进行再次尝试，只有所有可能都尝试过后，才会最终宣告匹配失败。

                即匹配优先和忽略优先是为全局匹配服务的。在寻找到最终的匹配结果前，不同的例子使用
                匹配优先和忽略优先只是尝试的次数不同，即效率的差异。

            占有优先量词和固化分组

                上面的2.345匹配成功替换为2.34的问题根源在于：[1-9]?匹配字符后，\d+匹配失败进行回溯，
                从而匹配成功了，而我们需要的是匹配失败，从而不进行替换。
                所以我们需要[1-9]?匹配到5后抛弃备用状态，从而不让表达式进行回溯，最终匹配失败。
                但对于2.3400这样的例子我们又需要备用状态进行回溯，从而匹配成功，替换为2.34。

                所以需求为在某个可选元素匹配成功的情况下才抛弃它的“忽略”备用状态。即[1-9]?匹配到
                数字以后才抛弃它产生的备用状态。

                用(?>...)实现固化分组

                    注意它和逆序环视的区别，逆序环视是(?<=...)或(?<!...)

                    在固化分组结束时，它已经匹配的文本被固化为一个单元，只能作为整体
                    保留或放弃，括号内的子表达式未尝试过的备用状态都不存在了，所以回溯永远
                    都不能选择其中的状态。

                    表达式(\.\d\d(?>[1-9]?))\d+即解决了上面对2.34和2.345需要匹配失败的问题。

                    (?>[1-9]?)中[1-9]?的量词?仍然有效，?是匹配优先,所以先进行尝试匹配[1-9]，

                    若[1-9]没有匹配到文本(如2.34和2.3400),固化分组内也不会保存备用状态，
                    此时表达式回溯到?的忽略状态，继续匹配后面的\d+.

                    若[1-9]匹配到了文本，固化分组抛弃?的“忽略”备用状态，文本2.345继续向后
                    匹配\d+时匹配失败，此时回溯没有备用状态可选，故匹配失败，从而达到我们不替换的目的。

                固化分组的要旨

                    即匹配优先和忽略优先不会影响检测路径本身，而只是检测的顺序。
                    而固化分组放弃了某些可能的路径，从而会影响最终的匹配结果。

                    表达式(\.\d\d(?>[1-9]?))\d+为例

                    1. 毫无影响 如文本2.345000
                    2. 导致匹配失败，如文本2.344
                    3. 改变匹配结果，如文本2.344
                    4. 加快报告匹配失败的速度

                    表达式(?>.*?)无法匹配到任何字符，因为.*?表示忽略优先，未忽略作为备用状态，一旦
                    退出固化分组，该备用状态被忽略，这样能匹配到的值总是被忽略，即无法匹配到任何值。

                    使用固化分组加快匹配失败的速度
                        如表达式^\w+:匹配文本Subject,一眼可以看出不匹配，因为文本中没有冒号，但
                        表达式中\w+会先匹配到Subject,然后冒号无法匹配末尾，不断回溯直到S才宣告失败，效率太低。
                        因为\w代表单词，它匹配的内容中不可能出现冒号，所以可以直接对其进行固化分组
                        ^(?>\w+):即可。

                        即如果存在可以匹配的文本，固化分组并不影响正常的匹配过程
                        如果不存在能够匹配的文本(如上文中的\w不能匹配冒号),那么使用固化分组删除无用的备用状态
                        可以加快匹配失败的速度，从而提高效率。

                    占有优先量词 ?+, *+， ++和{m, n}+

                        同忽略优先?尽可能少的匹配不同，占有优先+匹配后删除备用状态，效果和固化分组相同。

                        注意比较(?>M)+和(?>M+)的区别
                            前者M本身没有修饰符，不产生备用状态，使用固化分组没有意义，实际中应避免这样的写法。
                            后者对M+的备用状态进行抛弃，即相当于M++.
                            如例子(A|b)*+转化成固化分组形式若为(?>A|b)*就相当于(?>M)*是错误的，
                            正确形式应为(?>(A|b)*),即去掉占有优先量词的+号，剩余部分用括号括起来才是正确的。

                    环视中的回溯
                        因为如果环视时子表达式能够成功匹配，则环视过程中保留的备用状态会全部清空。
                        而如果不能够成功匹配，它会进行回溯直到没有备用状态可以回溯为止。
                        所以无论子表达式是否匹配,它都不会留下任何备用状态。
                        这样环视和固化分组，占有优先量词是相同效果的。

                        用肯定环视模拟固化分组
                            即(?>regex)用(?=(regex))\1来替代
                        多选结构也是匹配优先吗

                            对于传统NFA来说，多选结构既不是匹配优先，也不是忽略优先，它是按顺序排列的。
                            从而使用者可以指定尝试匹配的先后顺序。
                            Perl, php, .net, java都是传统型NFA引擎

                            对于POSIX NFA来说，多选结构是匹配优先的.它会尝试所有可能找出最长者。

                        发掘有序多选结构的价值
                            对于前面的保留小数的例子
                            (.\d\d[1-9]?)\d* 它并不等价于(.\d\d|.\d\d[1-9])\d*,
                            因为多选结构的有序性，第3位为数字时匹配到了\d*,而不是需要的[1-9]
                            但通过调换顺序,(.\d\d[1-9]|.\d\d)\d*就实现了匹配优先的功能。
                            (ab)*|b*多选结构没有意义，因为(ab)*永远不会失败
                        有序多选结构的陷阱
                            对于日期的匹配如 7.9 7.09 7.10 7.20 7.31中的天数
                            如果用表达式(0?[1-9]|[12][0-9]|3[01])来匹配，那么
                            由于多选结构的有序性，当文本为7.11时，0?[1-9]匹配到了7.1，而后面的1就被忽略了
                            从而失败，这主要是由于多选结构较短的分支在前面率先匹配成功从而导致的错误，
                            改变顺序为([12][0-9]|3[01]|0?[1-9])即为正确答案。
                            另，可以用不同的日期划分方式来避免分支长度不同引起的问题
                            即将单个数字按首位拆分到不同分支中去
                            (0[1-9]|[12][0-9]?|3[01]?|[4-9])
        NFA, DFA和POSIX
            最左最长规则
                针对文本abc,表达式ab*(bc)*在传统型NFA和DFA引擎下有不同的表现
                传统型NFA的b*中*是匹配优先，匹配到ab，后面的(bc)*就不满足匹配条件，即只能匹配到ab
                而DFA是文本主导，匹配时记录所有可能，它以匹配长度最长的可能,所以能够匹配到abc
            POSIX和最左最长规则
                NFA在第一次匹配成功时就会停下来，如果让它继续匹配其他分支，从中找出最长的分支，
                即可以实现leftmost the longest。
        速度和效率
            DFA的效率
                DFA相当于针对正则表达式进行分析得到一张路线图，从而在实际匹配文本时可以得出全部的可能。
        小结：NFA和DFA的比较
            DFA和NFA: 在预编译阶段的区别
                NFA通常快一些，需要内存也更少一些
            匹配速度的差别
                一般来说，DFA的速度与正则表达式无关，NFA是两者直接相关
                NFA匹配成功前会尝试所有可能，所以优化很重要，
                POSIX NFA会尝试所有可能找出最长者，优化更重要。
                DFA匹配速度很快，不需要太多优化，它在预编译阶段的优化效果要比大多数NFA好
                DFA会尝试在匹配需要时再进行预编译,可以节省很多内存和时间。
            结果的差别
                DFA是leftmost the longest,NFA不一定，但没有硬性规定。
            能力的差异
                NFA比DFA提供了更多的功能
                    1. 捕获子表达式匹配的文本 如反向引用
                    2. 环视
                    3. 非匹配优先的量词以及有序的多选结构
                    4. 占有优先量词和固化分组
                兼具DFA的速度和NFA的功能: 正则表达式的终极境界
                    GNU grep尽可能多的使用DFA,在需要反向引用时就切换到NFA.

            实现难度的差异
                简单实现NFA或DFA引擎很容易，但为了提高性能引擎的代码量大幅增加


chapter 5 正则表达式实用技巧

    正则表达式的平衡法则
        1. 匹配到期望的文本，排除不期望的文本
        2. 必须易于控制和理解
        3. 如果使用NFA,必须保证效率
    若干简单的例子
        匹配连续行
            如用^\w+=.*(\\\n.*)*不能用于匹配用反斜线\分隔的连续多行
            因为.*也会匹配到反斜线，从而匹配不到
            这样就可以不用.号，用[^\n\\]来替代它，其中\n是点号本身就不匹配的内容
            也可以用用另一种思路，不是匹配完一行检查换行符，再匹配，
            而是整体考虑，要么匹配的是普通字符，要么是反斜线和换行符的结合体
            在点号通配模式下，可以用^\w+=([^\n\\]|\\.)*来匹配
            文本x=y sd sd \
                sd sd sd d\
                dd
            的内容
        匹配IP地址
            ip地址从0.0.0.0到255.255.255.255之间，每个数字可以是1位，2位，3位，数字取值为0-255之间。
            可以用表达式\d|\d\d|[01]\d\d|2[0-4]\d|25[0-5]来匹配这个取值区间
            由于NFA的多选分支匹配失败回溯的特性，需要尽可能减少多选分支数
            可以合并前3个分支，为[01]?\d\d?|2[0-4]\d|25[0-5]
            在具体应用时，完全可以用^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3}))$来匹配
            之后再程序中使用$1,$2,$3,$4来获取值进行处理即可。

            确定应用场合context
                如果没有上门的^和$,它可能匹配到11234.3.4.5,也可能匹配到123.123.4.212中最后的21
                后者是因为前面提到的多选结构的有序性，匹配了2位数字后匹配即成功，没有$来强制继续匹配。
                前者如果用单词分界符来分隔，也无效，因为\w是[0-9a-zA-Z],
                \b即是一侧有字母数字，另一侧没有字母数字的位置。
                对于文本1.2.3.5.6来说，这样也是符合单词分界符的要求的。
                即可以用环视功能(?<![\w.])...(?![\w.])来去除数字和点号的存在
                或即简单的( |^)...( |$)即可。
        处理文件名
            去掉文件名开头的路径
                linux或unix路径中，路径以斜线分割
                    perl $f = s{^.*/}{};
                    java f = f.replaceFirst("^.*/", "");
                windows路径中，路径以反斜线分割
                    perl $f = s{^.*\\}{};
                    java f = f.replaceFirst("^.*\\\\", "");
                其中^不可忽略，若没有它，NFA在匹配.*时没有匹配到斜线，传动装置会向后传动，再次进行无用
                的匹配，因为第一次.*就证明了不可匹配，从而浪费了时间。
            从路径中获取文件名
                另一种办法是简单匹配路径最后的文件名部分，即最后一个/后的部分，可以用排除型字符组。
                $path =~ m{[^\]*$}; print "$1\n";
                [^\]*$在NFA中同上面单独的.*/(无锚点^)一样，回溯加传动装置浪费了大量时间，
                但这里理解问题本身才是重要的，即匹配最后文件名部分用排除性字符组的思路很重要。
            所在路径和文件名
                可以简单的用^(.*)\(.*)$中$1,$2来获取文件路径和文件名，
                由于*的匹配优先可以确保得到正确的结果，也可以进一步明确化为
                ^(.*)/([^/]*)$
        匹配对称的括号
            对于文本val = foo(bar(3), 5) + 2 * (3 + 1);来说，需要获取到括号中(bar(3), 5)的内容

            1. \(.*\)  简单的.* 匹配到了文本(bar(3), 5) + 2 * (3 + 1)
            2. \([^)]*\)  排除了右括号的排除性字符组，但不支持嵌套，匹配了(bar(3)部分
            3. \([^()]*\) 同时排除了左右括号，但只能匹配到(3),不合要求

            针对该一重循环可以写为 \([^()]*\([^()]*\)[^()]*\),即重复使用2表达式即可
            任意深度嵌套可以使用perl提供语言的特性，string x count运算符

        防备不期望的匹配

            仍是讲*可以匹配空的问题，如用-?[0-9]*\.?[0-9]*来匹配一个浮点数，
            但它没有一个部分是必须匹配的，都是可选部分，所以它可以匹配空字符串。
            其中小数点若出现，它后面必定是要接数字的，所以不应是.?，而是限制整体.
            可以修改为-?([0-9]+(\.[0-9]*)?|\.[0-9]+)
            但它仍然可以匹配2003.03.03这样的文本，因此需要将表达式放入具体情况中，如^$中

        匹配分隔符内的文本

            容许引文字符串中出现转义引号

                针对文本"1232\"sd\"xsd"需要匹配整个文本所在引号内的内容，即允许其中存在转义的引号出现。
                1.  从左向右匹配，中间正文为非引号部分和转义的引号部分，所以可以用环视功能来解决
                    "([^"]|(?<=\\)")*"

                    但这样有一个问题，即文本中是\\" x"a b"的情况，此时前面的\转义的是后面的\，此时后面的"应是
                    结束的双引号，但上面的表达式则会匹配到x"部分，所以行不通。

                2. 换种思路，我们需要的正文为任意转义的字符部分或非引号部分，即不只是转义引号，将它扩大化，
                    可写为"(\\.|[^"])*"

                    但这样也有问题，如文本"weAreThe\x\"adbs
                    它没有结束的引号部分，但匹配时匹配到最后，进行回溯到\"时，最后的”匹配到了表达式需要的“，
                    而前面的\则匹配到了[^"]部分
                    即根本原因是\\.可以正常匹配到\"，但[^"]"也可以匹配到\".
                    所以多选分支的可匹配部分出现了重叠，
                    只需将[^"]部分去掉匹配\即可，所以正解即为
                3. "(\\.|[^\\"])*"
                4. 利用固化分组或优先量词可以避免表达式回溯产生有问题的匹配
                   "(\\.|[^\\"])*+"或 "(?>(\\.|[^\\"])*)"

        了解数据，作出假设

            知道什么假设很重要，通常假设过于乐观，值得注意。

        去除文本首尾的空白字符

            最简单
                s/^\s+//;
                s/\s+$\\;
            1. s/^\s*(.*?)\s*$/$1/  忽略优先，但需要多次回溯检查\s*$，效率低
            2. s/^\s*((?:.*\S)?)\s*$/$1/  非捕获型括号得到一个最后非空白字符.
            3. s/^\s+|\s+$//g   顶级的多选分支结构的表达式很难优化，\g是从上次匹配成功后的位置继续匹配

        HTML相关范例
            匹配html tag
                常用的匹配tag的表达式为<[^>]+>,但它对于文本<div class=">">出错，
                所以可以将引号内和引号外部分用多选分支区分开来，
                即<('[^']*'|"[^"]*"|[^'">])*>
                其中最后一个表达式[^'">]如果加+号，与外面的*号会产生奇怪的结果，下一章介绍。
                可以将括号内的表达式写为固化分组(?>)或*+占有优先量词。
                因为多选分支之间没有重复，一个匹配其他肯定匹配不了，这段匹配成功后如果后面匹配失败不用回溯到多选分支处。
                即若后面的>匹配失败，也不用回溯到其他多选分支处,所以可以用固化分组。
            匹配html link
                针对文本<a href="www.baidu.com">baidu</a>获得其中的url链接和链接文本baidu
                可以用<a\b([^>]+)>(.*?)</a>来匹配，
                其中$1获得了url,用表达式
                $guts =~ m{
                    href
                    \s* = \s*
                    (?:
                        "([^"]*)" |
                        '([^']*)'|
                        ([^'">\s]+)
                    )
                }xi
                其中$1,$2,$3分别用于捕获多选分支的可能捕获结果，实际上只有一个会有值。
                $url = $+;
                perl中的$+变量可以得到$1,$2...中编号最靠后的捕获文本（有值？）如果支持命名捕获，可以在程序中进行判断。
            检查http url
                $url =~ m{^http://([^/:]+)(:(\d+))?(/.*)?$}i
            验证主机名
            在真实世界中提取url
            扩展的例子
                保持数据的协调性
                    如在一系列的5位邮政编码中匹配到以44开头的编码，表达式\d\d\d\d\d匹配时传动装置默认逐个字符移动，
                    从而导致匹配出错，需要让它匹配时跳过整个邮编，保持正则引擎的协调。
                根据期望保持匹配的协调性
                    为了匹配到需要的44开头的邮编，可以将非44开头的邮编用非捕获括号括起来，加在期望匹配的44表达式前
                    1. (?:[^4]\d\d\d\d|\d[^4]\d\d\d)*
                    2. (?:(?!44)\d\d\d\d\d)* 正向否定环视
                    3. (?:\d\d\d\d\d)*? 忽略优先量词 最符合需求要求，一开始该忽略优先为空，若后面的44\d\d\d匹配失败，
                        则回溯后，前面的忽略优先表达式匹配5位数字，完美的跳过了该非期望邮编。
                不匹配时也应当保证协调性
                    上述表达式在匹配过一轮后，若没有匹配成功，经过传动装置传动，一样会产生匹配错误的情况。
                    对于1和2表达式，可以在44\d\d\d后加上?号，这样期望匹配的文本就变成可选项，
                    不会产生由于必须匹配而发生的强迫传动，但这样会导致a*b?即无目标文本时也匹配成功的情况发生，虽然避免了错配
                    对于表达式3，由于它是忽略优先，需要44\d\d\d进行强制匹配以推动匹配过程，加上？号后变成可选，
                    表达式实际匹配在字符串开始处就停止了。
                使用\G保证协调
                    \G is an anchor; it indicates where the match is forced to start. When \G is present, it can't start matching at
                    some arbitrary later point in the string; when \G is absent, it can.
                    \G保证了匹配的连续性，即一旦发生传动，匹配立刻失败。
                    @zips =~ m/\G(?:(?!44)\d\d\d\d\d)*(44\d\d\d)/g;
                    这样就不用在后面的程序中针对不存在目标字符串也匹配成功的情况进行处理了。
                    Usually when a global match fails, Perl resets the position to -1, which is right before the start of the
                    string (position 0), so the next global match starts at the beginning of the string.
                    However, if you use the /c match operator flag, you can try a match without resetting the match
                    position if it fails
                    即/c在全局匹配失败时不会回到字符串开头，而是留在上次匹配成功后的位置。perl中可以用pos($string)来查看匹配的位置。

                    As with any other match operation, unless you anchor your regex, the match operator will move the pattern
                    leftward across the string looking for a match. A global match has a special anchor, the \G, that constrains
                    the next global pattern to start at the current match position. If you wanted to check if there is
                    whitespace right after the match position, you’d anchor the next part of the pattern with \G:

                    In scalar context, a global match starts where you left off in that string
                    The /c prevents the match operator from resetting the match position as a failure
                    Using /gc allows you to separate alternations in separate regexes instead of one big and ugly regex
        Parsing CSV Files
            csv files are values seperated by commas.
            there are different format about csv,here is the microsoft excel's csv,
            text:
                ten thousand,10000, 2710 ,,"10,000","It's ""1000 Grand"", baby",20K
            the values are
                [ten thousand][10000][ 2710 ][][10,000][It's "1000 Grand", baby][20K]
            so the regular expression can be: [^,"]+|"(?:[^"]|"")*"  inside use ?: because we don't want to match the single word
            each field value can be captured like this: ([^,"]+)|"((?:[^"]|"")*)",then in perl
            defined $1,$2 is true or false to judge which parenthesis captured the value.

            but how can we get catch  ,, empty field?

            if we turn [^,"]+ to [^,"]* then it can match nothing,right after matching ten thousand position,it matches,
            in fact,it can match unlimited times,but modern regular engine can't allow two zero-length matches happen in a row,
            so it will match one time and force a bump along, and it results with each empty match between each valid match including
            the two parts (with or without quote).

            distrusting bump along
                add the (?:^|,)to the beginning of the regex,

                    (?:^|,)(?:([^",]*)|"((?:[^"]|"")*)")

                        attention:
                            the ?: is only used for the alternative restriction.
                            and the () is used to catch the needed field.
                and see this output
                first! [ten thousand]
                first! [10000]
                first! [ 2710 ]
                first! []
                first! []
                first! [000]
                first! []
                first! [ baby]
                first! [20K]
            because the first alternative is ([^",]*) which requires nothing to match suceessfully, and there's nothing behind the
            alternative,so the second alternative is never reached.
            we can swap the alternative and it works.

            so we should put the match range which is small in the front.
            and we can use \G to control the matching process is precise and disallow the bumping match.
            In the above example,use m{\G...}gx get the result [ 2710 ][][],
            because the ,,get one [],and it get "10, " didn't match the [^",], so it is matched as *'s null and get one [],
            and the \g match need the regex to bump to match the ^|, beginning, as bumping the whole "10 to get the next comma,
            so this is the time \G prevent this happening and not matching to exit the while loop.

            code:
            $test = "ten thousand,10000, 2710 ,,\"10,000\",\"It's \"\"1000 Grand\"\", baby\",20K";
            while ($test =~ m{\G
                    (?:^|,)(?:
                            "((?:[^"]|"")*)" |
                            ([^",]*)
                           )
                    }gx) {
                if(defined $1) {
                    print "doubleQuote! ";
                    $field = $1;
                    $field =~ s/""/"/g;
                }else {
                    print "noQuote! ";
                    $field = $2;
                }
                print "[$field]\n";
            }
            the \G here makes error more apparent,because the result will show where the match process stops.
            in this regex, it seems \G will never be used.

            another approach:
                if we don't want match the comma and we can begin the match with the location we demanded using the lookaround.
                but because the variable length of look behind is not allowed, so we get regex like (?:^|(?=,)),
                but it also rely on the bump system to pass the comma,when something is wrong, it could still begin the match
                from example above like "10,000"'s ,000,it just pass the "10 to get the ,000.
                but we can match the end using (?=$|,) to ensure the match won't happen before the "10 and it must match the end
                of line or one comma.
            one change for the efficiency
                (?:[^"]|"")*  can be changed to
                (?>[^"]+|"")*  or  (?:[^"]++|"")*+
                using atomic grouping or possessive quantifiers
                reason will be explained in next chapter.
            other csv format
                about the same and needs little adjustment.

chapter 6 crafting an efficient expression

    mainly for NFA engine, the regex-directed match process.

    A sobering example
        (\\.|[^"\\])* to match the content between the quotes and it can have escaped quote.
        every normal word(non-quote and non-escape character) has to fail the \\. it's inefficient.
    A simple change - placing your best foot ahead
        swap the alternatives like ([^"\\]|\\.)* obviously removes the backtracking times, as there are more normal words.
        posix nfa try all the alternatives,so this order change has no effect.
        and when there's a match,the traditional nfa indeed increase performance(less backtracking),but it's the same when
        there are no mactches at all, because it must have tried all the alternatives.
    Efficiency vs correctness
        you should comfirm the correctness of the regex before change it because of the efficiency.
    Advancing furthur-localizing the greediness
        for regex ([^"\\]|\\.)* every normal word has to enter into and out of the parenthesis,it costs more(the engine need to
        keep track the text which matches inside the parenthesis).
        So turn into ([^"\\]+|\\.)* add a plus can reduce the star iteration and improve performance.
        but in posix nfa,this regex needs a huge amount of time to run,because it needs to try all possibilities and +,* are both
        functioning.

    Reality check
        "exponential" matches
            because the regex ([^"\\]+)* has many combinations, for each target string character it has two
            possibilities(+ and *),for example, text "qwerer" can mean + matches 1 character and 6 *
            iteration, or + matches 2 characters and 3 * iteration,etc.This is called exponential matches
            or super-linear matches.

            traditional nfa will stop at the first full match,but it also has this problem, it may take
            a long time to the right match or report failure.But DFA is text-directed and keeps all the
            possibilities,so it will be fast.

            so this kind regex ([^"\\]+)* can reflect the regex engine type in some extent.

    A global view of backtracking
        more work for posix nfa
        work required during a non-match
            if use the regex ".*"! to match text sdf"sdf"asdfd"sdfsd"sd
            it will try from the first quote and track back several times, then failed, bump along to
            next quote and repeat the process again to the end, until then it will report failure.
        Being more specific
            using "[^"]*" to replace ".*" can reduce much more matching and subsequent backtracking.
        alternation can be expensive
            such as regex u|v|w needs more backtracks than a character class [uvw].
        benchmarking
            we need to repeat the matching process to make the time cost long enough to make sense,like
            other performance tests. And the real work part matters more importantly than the non-work
            part.
            while($count-- > 0) {
                $testString =~ m/^(a|b|c|d)+$/;
            }
            if the count is too big, then it will cost more overhead like the update and test of variable
            count, and the setup of the regex engine, the extra work of the capturing parenthesis.

            benchmarking with java
                Matcher regex1 = Pattern.compile("^[a-z]+$").matcher("");
            while(--count > 0) {
                regex1.reset(testString).find();
            }
            the time is influenced by the compiler speed.And after long enough time,the code will become
            hot for the vm,and the time cost will be slightly shorter.

    Common Optimizations
        Doing something faster
        Avoiding work

        No free lunch
            \b\B optimization to report failure fastly can save a lot,but it is very rare,so
            it is not worth to optimize this.
        everyone's lunch is different
            different engines have different implementation ways for same optimization,
            one change is faster for one kind engine and slower for another.
        The mechanics of regex applications
            1. regex compilation
            2. transmission
            3. component tests
            4. finding a match
            5. transmission bump-along
            6. overall failure
        Pre-Application Optimizations

            compile caching
                compile caching in the integrated approach
                    perl and awk are integrated approach,the regex is cached the first time executed.
                compile caching in the procedural approach
                    gnu,tcl keeps a cache of recently used expressions,if not used,it is compiled from scratch.
                compile caching in the object-oriented approach
                    java, python, .net can compile regex according to the user.
                pre-check of required character/substring optimization
                    we can check single required word in target text,most time the multiwords' check is thwarted
                    by alterantion. th(is|at) is better than this|that
                length-cognizance optimization
                    \d{3} the target text has at least 3 digits

            Optimizations with the transmission

                start of string/line anchor optimization
                    ^(this|that) is better than ^this|^that,and it can match ^ only in location where ^ is.
                implicit-anchor optimization
                    regex starts with .* or .+ can prepend ^ to the beginning.but within parenthesis,we need
                    to be careful.
                end of string/line anchor optimization
                    regex test(34)?$ can match at most 6 characters from the end,so the transmission can
                    jump directly to that spot.
                Initial character/class/substring discrimination optimization
                    [this|that|other] can match text starting with [ot].
                Embedded literal string check optimization
                    similar to the upper one,but the string can be inside the text,but it need
                    a fixed distance.
                length-cognizance optimization
                    same to the upper length-cognizance optimization

            Optimizations of the regex itself

                literal string concatenation optimization
                    regex abc be treated as one part,not a,b,c
                simple qunatifier optimization
                    with this optimization,engine can deal with .* faster than (?:.)*
                needless parentheses elimination
                    (?:.)* is same with .*
                needless character class elimination
                    [.] turns into \.
                character following lazy quantifier optimization
                    regex .*?sd checks the target text for sd, until then the lazy quantifier .*? act
                    like greedy ones.
                "excessive" backtracking detection
                    regex (.+)* can make exponential backtrackings,we can limit the size of
                    total backtrackings or the size of the stack of backtrackings.
                    But they all can limit some of the normal use of regexes like .*? ,
                    so we should know about this limit.
                exponential(super-linear) short-circuiting
                    a quantifier loops more times than the characters' size is a sign of exponential
                    match.Like the (.+)* grouping(12 words group by 2*6,3*4),we can keep track
                    of the positions each subexpression and avoid repeating attemps.
                    but detect and eliminate redundant matches is tough.
                    this optimization may hide the inefficiency of the regex,as it failed quickly.
                state-suppression with possessive quantifiers
                    we don't need the remove all the previous states after the possessive
                    quantifier end its course,we can remove extra states on the fly,and leaves
                    one state to go back while matching failed,it can save a lot of memory.
                small quantifier equivalence
                    for perl,python,.net \d{3} is 20% faster than \d\d\d, and
                    in java and ruby, \d\d\d is faster.
                    === literal character can use the optimization above.
                need cognizance
                    tcl capturing parentheses really captures when asked, and .net
                    can make the user indicate not to capture.It can save overhead.

            Techniques for faster expressions

                write to the optimizations
                    xx* can use more optimizations than x+
                mimic the optimizations
                    add (?=t) to the beginning of (this|that) mimic the initial-character
                    discrimination optimization
                lead the engine to a match
                    th(?is|at) is mathched more quickly than this|that,we should
                    do so to lead more quickly match.
            Common sense techniques
                avoid recompiling
                use non-capturing parentheses
                don't add superfluous parentheses
                don't use superfluous character classes
                use leading anchors
            Expose literal text
                "factor out" required components from quantifiers
                    use xx* instead of x+
                "factor out" required components from the front of alternation
                    use th(?:is|at) instead of this|that
            Expose anchors
                expose ^ and \G at the front of expressions
                    ^(?:abc|123) is better than ^abc|^123
                    ^(abc) is better than (^abc)
                expose $ at the end
            Lazy versus Greedy: Be Specific
                depends on the situation,lazy for the front,greedy for the end and the random position.
            Split into multiple regular expressions
                sometimes the optimizations needed to kick in just don't,we can do it ourselves with
                another expression.
            Mimic initial-character discrimination
                we can prepend look-ahead ourselves to mimic this
                don't do this with tcl
            Use Atomic Grouping and Possessive quantifiers
                ^[^:]+: can be replaced by ^[^:]++: or ^(?>[^:]+):
                it can avoid unfruiteful backtrackings
            Lead the engine to a match
                put the most likely alternative first
                distribute into the end of alternation
                    this optimization can be dangerous,because it maybe defeat other native optimizations
            Unrolling the loop

                method 1: building a regex from past experiences
                    from "(\\.|[^"\\]+)*" examples we can get the pattern
                    "[^"\\]+(\\.[^"\\]+)*"

                    constructing a general "unrolling-the-loop" pattern
                        to match examples with escaped characters beginning and escaped characters in a row,
                        we can get "[^"\\]*(\\.[^"\\]*)*",and by emptify each star we can prove it's ok.
                    the real "unrolling-the-loop" pattern
                        the pattern is
                        opening normal* (special normal*)* closing

                        Avoiding the neverending match
                            the start of special and normal must never intersect
                                when they are not intersected, the special normal* sequence is much more
                                efficient and avoid never ending match.
                                the special acts like checkpoints, preventing (normal*)* various combinations.
                            special must not match nothingness
                                the special can be null and lose the checkpoint's function
                            special must be atomic
                                this means text matched by one application of special can't be matched
                                by mutiple applications of special at the same time,it lead back the
                                original problem.
                            general things to look out for
                                the valid (*)* all have checkPoints inside
                nethod 2: A top-down view
                    common normal parts end, we can expect special part like escaped character or
                    ending quote, after escaped character we get another normal part and we can
                    start again making choice about excaped and ending quote,thus we can get the
                    same regex like method 1.

                method 3: An Internet Hostname
                    the example is similar to the hostname,we can think it as sequences of
                    non-escaped stuff seperated by escaped items.There are some difference
                    between them such as the beginning and ending can't have delimiters, the
                    delimiters can't put in a row, but they are the same class in this view.

            Observations

                "[^"\\]*(\\.[^"\\]*)*"
                pitfalls: readability, maintainability
                benefits: speed, more speed

            Using Atomic Grouping and Possessive Quantifiers
                making a neverending match safe with possessive quantifiers
                    for regex ([^"\\]+|\\.)* it's ok to possessify both the + and * outside
                making a neverending match safe with atomic grouping
                    (?>(...|...)*) is same to (...)*+, not (?>...|...)*, the latter didn't
                    throw away the *'s states.
            Short unrolling examples
                unrolling "multi-character" quotes
                unrolling the continuation-line example
                unrolling the csv regex
                unrolling C comments
                    to unroll or not to unroll
                        lazy-quantifier make matching c comments /\*.*?\*/ easier and faster
                        than unrolling technique,but it's still useful in case lazy-quantifier
                        is not supported or optimizations mixing are not fast enough.
                    avoiding regex headaches
                        to be able to read more easily,turn /**/ to /xx/
                        /x[^x]*x/
                    a direct approach
                        /x(?:(?!x/).)*x/ using look-ahead can solve this,but it's slow,and
                        if it can support look-ahead,it will support lazy quantifier.
                        take x and / separately
                        regex1: /x([^x]|x[^/])*x/    wrong for /xx foo xx/
                        regex2: /x([^/]|[^x]/)*x/    wrong for /x/ foo /x/ and /xfoox//s
                    making it work
                        for /x([^x]|x[^/])*x/
                        (x[^/])* can match the ...xxx/ while the / match the [^x]
                        we can make it (x+[^/])*, but the [^/] can still match x, when
                        backtracks, it still match xxx.
                        so we can make it like (x+[^/x])*, thus it will match xxxa,
                        but when come to xxx/,x+ match xxx, and [^/x] can't match /,
                        so it backtracks all the way to the beginning of xxx/,
                        so we have to change the end to x+/,so the final regex is
                        /x([^x]|x+[^/x])*x+/,and we can change x to \* to make it really work.(not
                        needed in character class)
                    unrolling the c loop
                        the normal part here is [^x]*x+, special part is [^/x]
                        regex is /x[^x]*x+([^/x][^x]*x+)*/

                        return to reality
                            for egrex, multiline comment is a problem
                            and to some c programme sentences(like "/*"), it may falsely matched as a comment.

            The Freeflowing Regex

                A helping hand to guide the match
                    in perl:
                    $comment = qr{/\*[^*]*\*+(?:[^/*][^*]*\*+)*/};
                    $double = qr{"(?:\\.|[^"\\])*"};
                    $text =~ s/($double)|$comment/$1/g;
                A well-guided regex is a fast regex

                    $other = qr{[^"'/]};
                    ...
                    $text =~ s/($double|$single|$other+)|$comment|$comment2/$1/g;

                    keep the quotes and normal c code, remove the comment parts.
                    we can furthur optimize the alternative to
                    s/($other+|$double$other*|%single$other*)|$comment|$comment2/$1/g;
                Wrapup
                    use unroll-the-loop technique to optimize the double quote and single quote
                    and the perl's qr/.../ operator make it quite simple to build a regex.

            In summary: Think!
                d
