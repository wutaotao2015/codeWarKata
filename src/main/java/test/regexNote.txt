
chapter 1  入门
    1. 以文件名类比
    2. 以语言做类比
        元字符和普通字符
    3. 检索文本文件 Egrep
    4. Egrep
        grep为(global search regular expression and print out the line)为文本搜索工具
        egrep用于在文件内查找指定的字符串，效果相当于grep -E，目前直接调用egrep已废弃？用grep -E
        grep是使用basic regular expression,egrep使用extended regular expression,后者更规范

        元字符
            脱字符^: 字符串的开始caret(脱字符，插入记号（即快捷键中的光标))
            美元符号$： 字符串的结束
            以字符来理解正则表达式，
            如^cat表示的是以字符c开始的一行，后面紧接a和t字符
            即它们匹配的都是一个位置。
        字符组
            匹配若干字符之一
            <H[123456]>匹配<H1>,<H2>等html标签
            [0-9A-Z_!.?]匹配一个数字或大写字母，_或!或.或？,
            即在字符组[]中特殊字符只有连字符-(连字符在开头，紧接[时不是元字符,不是范围,为普通字符)
            ^cat$ 匹配只有cat的一行，不含多余字符
            ^$ 匹配一个空行 无任何字符，也不含空白字符
            ^ 匹配一行的开始，所有行都满足条件，无意义

        排除型字符组 （需要匹配一个字符，包括空白字符）
            [^1-6] 匹配除了1到6之外的任何字符，脱字符^只有紧跟[后才是元字符
            q[^u]无法匹配到Iraq
            是因为Egrep自动把换行符去掉了，若换行符没有去除，它仍是可以匹配到的
            这里说明的是排除型字符组也需要匹配一个字符
        用点号匹配任意字符 （需要匹配一个字符，包括空白字符）
            3344.55 可以匹配到 3344 55
            但33.44.55 无法匹配到 3344 55
            即点号也需要匹配到一个字符，无字符是无法匹配到的，空白字符也是一个字符
            33[-./]44[-./]55更精确，但读写消耗较大，33.44.55不够精确，但可读性和可写性强，
            在不可能匹配到非期望结果的情况下，33.44.55更佳。
            所以清楚了解目标的文本对于正确编写正则表达式是非常重要的。
        多选结构
            匹配任意子表达式
                | 表示或者(它是贪婪匹配的)，把不同的子表达式组合成一个总表达式，这个总表达式可以匹配任意一个子表达式
                子表达式称为“多选分支”
                gr[ea]y grey|gray gr(e|a)y都可以正确匹配，
                而若去掉括号gre|ay或者gr[a|e]y都不可以匹配到grey或gray的字符串
                一个字符组只能匹配目标文本中的单个字符，而多选结构可以匹配完整的正则表达式

                如(grey|gray)|(grey|gray)可以匹配到greygray和greygrey。

                ^From|Subject|Date: 和 ^(From|Subject|Date): 匹配的结果大不相同
                如果希望每个多选分支前都有脱元符和其后有冒号，需要用括号来限制这些多选分支
                egrep '^(From|Subject|Date):' test.txt
                该命令会打印出以From:或Subject:或Date:开头的一行文本
        忽略大小写
            正则表达式本身没有提供这样的功能，但egrep工具提供了，可以使用-i参数使其在匹配时忽略大小写
            grep -Ei '^(From|Subject|Date): ' test.txt
            这样也可以匹配到FROM: 了。
        单词分界符
            部分egrep支持元字符序列，即\<和\>,它与\b功能相同？
            这里说的单词的开始和结束具体指的是字母数字符号的开始和结束，除了常见的空格分隔，
            dang-wer开始于d,结束于g,再开始于w,结束于r
            we'll开始于w,结束于e,开始于l,结束于l
            $199开始于1,结束于9
        可选项元素
            colou?r这个正则表达式中？只作用于之前紧邻的元素
            4th|4可以转化为4(th)?
            此时？的作用范围扩大到整个括号了
        其他量词： 重复出现
            +代表之前紧邻的元素出现一次或多次
            *代表之前紧邻的元素出现任意多次或者不出现
            即尽可能匹配多的次数
            ' ?'能够匹配一个空格， ' *'能匹配任意多个空格
            如匹配标签的<H[1-6] *>可以匹配<H1>,<H2   >
            <HR +SIZE *= *[0-9]+ *>看起来让人迷惑，是因为元字符*和+作用的是空格，即在正则表达式中空格也是普通字符之一
            每个量词都规定了自己匹配的上下限，有的下限为0或1，有的上限为1或无穷大
        规定重现次数的范围： 区间
            如[a-zA-Z]{1,5}
        括号及反向引用
            括号用途
            1. 限制多选项的范围|
            2. 若干字符组合为一个单元，受量词？或*号等的限制
            3. 记住包含的子表达式匹配的文本。

            反向引用： 括号记住了里面匹配的文本（不是模式），后面可以通过\1,\2等来重复该文本

            如重复单词the   the可以用\<([a-zA-Z]+) +\1\>来匹配
            \1,\2,\3表示第1，2，3组括号记住的文本内容，其顺序是按左括号从左到右的顺序进行的

        神奇的转义
            slash 斜线 /
            backslash 反斜线 \   需要匹配元字符本身时可以进行转义
            此时反斜线称为转义符（escape)
            大多数语言和工具支持字符组内部的转义，不过大多数egrep命令不支持，在字符组内部\是普通字符
        基础知识拓展
            语言的差异
                每种语言提供了自己的改进，形成了自己的流派
            正则表达式的目标
            更多的例子
                变量名
                    即标识符，包含字母，数字，下划线，但不能以数字开头,不能超过32位
                    [a-zA-z_][a-zA-Z_0-9]{0，31}
                引号内的字符串
                    "[^"]*"
                美元金额 可能有小数
                    $[0-9]+(\.[0-9][0-9])?
                http/HTML url
                    \<http://[-a-z0-9_.:]+/[-a-z0-9_:@&?=+,.!/~*%$]*\.html?\>
                    或者更简单
                    \<http://[^ ]*\.html?\>
                HTML tag
                    <.*>可以匹配多个标签，如<p>short</p>
                表示时刻的文字
                    12小时制是从12，1，2，...,10, 11计数，12小时制没有数字0开头，它是从12开始
                    12：00am 即半夜0点，12：00pm是中午12点
                    即（1[012]|[1-9]):[0-5][0-9] (am|pm)
                    24小时制（0?[0-9]|1[0-9]|2[0-3]):[0-5][0-9]
                    合并前2个多选分支，变为([01]?[0-9]|2[0-3]):[0-5][0-9]
                    根据书中匹配的阴影图可以有另外一种写法 ([012]?[0-3]|[01]?[4-9])

        正则表达式术语汇总
            正则 regex
            匹配 matching
            元字符 metacharacter
                只有在字符组外部且在未转义的情况下，*才是元字符，\*中*被转义了，而\\*没有
            流派 flavor
            子表达式 subexpression
                通常是括号内的部分，也可以指|分开的部分，也指单个字符
                H[1-6] *中1-6不是子表达式，因为它属于字符组，不可分割，[1-6]是子表达式
                量词（*，+，？）作用的对象就是它之前紧邻的子表达式，或者是用括号括起来的子表达式
            字符 character
            改进现状
                正则表达式的使用
                正则表达式的特性
                正则表达式的工作原理
            总结
                元字符分类
                    匹配单个字符 . [...] [^...] \char
                    提供计数功能的元字符 ？ * + {min, max}
                    匹配位置的元字符 ^ $ \< \>
                    其他元字符 | （...) \1 \2
chapter 2 入门示例拓展
    关于这些例子
    Perl简单入门
        变量以$开头，存储数值或文本
        变量可以出现在字符串中，会被其实际值取代,可以用Perl -w test.txt命令执行脚本程序（-w参数可以检查程序是否规范）
    使用正则表达式匹配文本
        $test =~ m/^[0-9]+$/
        若测试文本test中只包含数字，则该表达式值为true
    向更实用的程序前进
        $c =~ m/^[-+]?[0-9]+(\.[0-9]*)?$/   可以匹配负数和小数
    成功匹配的副作用
        正则表达式中的在匹配时，\1反向引用了之前匹配的文本，匹配成功后接下来的程序可以用$1引用相同的文本
        $c =~ m/^([+-]?[0-9]+)([CF])$/
        其中的括号既没有改变量词的作用范围，也没有改变|的意义，即加括号不影响匹配的文本，它是括号的第3种用法，为捕获型括号。
        代码示例：
        if($input =~ m/^([+-]?[0-9]+)([CF])$/){
	        $num = $1;
	        $type = $2;
	        if ($type eq "C") {
    错综复杂的正则表达式
        允许输入浮点数时，正则表达式变为 ^([-+]?[0-9]+(\.[0-9]*)?)[ \t]*([CF])$
        此时程序中区分摄氏度和华氏度的C和F的保存变量由$2变为$3
        如果不想更改程序中的$2,即这个小数部分程序中不需要用到的话，可以使用非捕获型括号（?:...）
        即只分组不捕获
        此时正则表达式变为^([-+]?[0-9]+(?:\.[0-9]*)?)[ \t]*([CF])$
        这时CF保存的变量（Perl中）即为$2,小数部分(?:)不影响捕获计数
        非捕获型括号可以提高匹配效率，使得括号区分度高，但提高了阅读难度，可以根据具体情况选择是否使用

        [ \t]*和（ *|\t*)的区别
            后者不能匹配空格和\t的混合，只能匹配多个空格或者多个制表符
            前者*限制的是字符组[ \t],所以每个字符都可以进行选择，即支持匹配两者混合的情况

    一点题外话——数量丰富的元字符

        字符串的元字符和正则表达式的元字符是不同的，它们有的是相同的意义，如制表符\t
        shell中的空格符，$, *, ?等也是其自身的元字符，需要与正则表达式区分开
        即有的时候需要在不同层级上同时使用元字符进行交互

        用\s匹配所有空白
            即相比[ \t]*,使用\s是更好的选择
            \s表示所有空白字符的字符组，包括了空格符，制表符，换行符，回车符
            用m/.../i可以匹配大小写，其他还有/g表示全局匹配
            程序中的$type eq "C"需要修改为 $type =~ m/c/i同时匹配大小写的c
            所以正则表达式的变化也会影响到程序的其他部分
        暂停片刻
            Perl的正则表达式中的元字符比egrep更多，java, python类似于Perl
            Perl和其他流派的正则表达式提供了很多简记法shorthands:
                \t \n \r \s \S
                \w = [a-zA-Z0-9] \w+即一个单词
                \W = [^a-zA-Z0-9]
                \d = [0-9]
                \D = [^0-9]
            匹配成功后，Perl可以用$1, $2等变量保存对应括号内子表达式匹配到的文本，
            使用这些变量就可以用正则表达式从字符串中提取我们所需要的信息
    使用正则表达式修改文本
        使用$var =~ s/.../.../ 即如果正则表达式能够匹配$var中的某段文本，就将这段匹配上的文本替换为后面的文本
        如
         $test = "HelloTest666Test";
         $test =~ s/Test\d+Test/999/;
         print "$test\n"
        输出结果为Hello999

        $var =~ s/\bJeff\b/Jeff/i
        其中/i限制的是对\bJeff\b中的Jeff的大小写情况，即不论Jeff的大小写情况如何，它会被统一替换为Jeff

        例子：公函生成程序
        s/regex/replacement/中的用于替换的replacement其实是perl中的字符串，
        可以像上面的程序那样引用变量
        \g全局替换修饰符，即第一次替换完成后继续搜索更多匹配文本，进行更多替换

        例子：修整股票价格
            23.423000000234小数点后第3位若不为0就保留3位，否则就保留2位，
            思路即对整个数字进行匹配，将需要保留的部分放入括号内，替换时利用括号捕获进行替换
            第3位利用[1-9]?)\d*来进行取舍
            $price =~ s/(\.\d\d[1-9]?)\d*/$1/
            小数点后面的\d*被正则表达式匹配上了，用$1替换时会被删除
        自动的编辑操作
            perl -p -i -e 's/X/wutaotao/g' 2test.txt
            -p 对每行进行查找和替换 和-n相似，循环
            -i 将替换结果写入文件 edit files in place
            -e 后面接的就是程序本身，省略了文件 one line program
            即通过一行命令可以替换多个文件中的多个字符
        处理邮件的小工具
            $line = <> 这条语句相当于getLine(),读入一行数据,为空时返回false
            如上面匹配html标签一样，<.*>中会匹配尽可能多的任意字符，使用时应注意前后端的表达式匹配的重复性问题
            针对发送地址的提取，如From: taotao@qq.com (wutaotao)需要提取其中的邮件地址和后面括号中的姓名
            ^From: (\S+) \(([^()]*)\)
            其中\S表示非空白字符，[^()]表示非括号的排除型字符组，值得注意的是在字符组内部括号不是元字符，不需要转义

            perl中while的break为关键字last
            在每行开头增加|> 可以用正则表达式
            while($line = < >) {
                   $line =~ s/^/|> /;
                   print $line;
            }
            由此可以得到类似的有效例子：
                perl -p -i -e 's/^/**/' 3Test.txt 开头增加2个星
                perl -p -i -e 's/^\*+(.*)$/$1/' 3Test.txt 去掉开头增加的星
        用环视功能为数值添加逗号（分位符）
            环视不匹配字符，只匹配位置，同^,$,\b相似
            顺序环视
                顺序查看文本（向右找），如果匹配子表达式，则匹配成功
                (?=...)
            逆序环视
                逆序查看文本（向左找），同样不消耗字符
            环视不会消耗字符（占用）
                环视可以精确定位到需要匹配的位置
                (?=Jeffery)Jeff与Jeff(?=ery)是等价的，最终匹配点位置停在了Jeffery的ff后。
                即前面的环视匹配成功后可以定位到Jeffery的前方，再进行匹配Jeff字符
                若环视匹配不成功，整个正则表达式也不会匹配成功
                如Jeff(?=Jeffery)就不能匹配上

                (?=) (?<=) (?:)都是有自己的"开括号"--(?, 没有普通括号的捕获功能。
            更多的环视例子
                如将see Jeffs book中Jeffs改为Jeff's
                应用环视的终极例子为
                    perl -p -i -e "s/(?<=\bJeff)(?=s\b)/'/g" 4test.txt
                    这个例子说明了（？=）是从目标位置的右边开始寻找，（?<=)是目标位置的左边开始寻找，
                    即一个是右边，一个是左边，具体的匹配过程仍然是从左到右的
                    两个位置限制都符合的情况下，该位置就被确定了
                    perl -p -i -e "s/(?=s\b)(?<=\bJeff)/'/g" 4test.txt
                    环视结构的顺序是无所谓的，因为它们都未消耗字符，同时满足就可以。
                    （最后加\i有问题）
            回到逗号的例子
                $popu = 12345678;
                $pop =~ s/(?<=\d)(?=(\d\d\d)+$)/,/g;
                print $pop;
                程序中的$保证了逗号后面的数字个数是3的倍数, 要插入逗号的位置前至少有一个数字
                其中（\d\d\d)是捕获型括号，会保存值到$1中，可以替换为(?:\d\d\d),不过可读性降低了
            单词分界符和否定环视
               $popu = "12345678 is growing"时$无法使用，因为数字后面还有内容，不是行尾
               所以可以用单词分界符\b代替
               否定环视
               正向肯定环视(positive lookahead) (?=)
               反向肯定环视(positive lookbehind) (?<=)
               正向否定环视(negative lookahead) (?!)
               反向否定环视(negative lookbehind) (?<!)
               所以单词分界符\b = (?<=\w)(?!\w)|(?<!\w)(?=\w)
               所以上述例子应写为$popu =~ s/(?<=\d)(?=(\d\d\d)+(?!\d))/,/g;
               \D代表某个不是数字的字符，它和(?!\d)不同,后者可以匹配空，前者必须要有一个字符
               不通过逆序环视添加逗号
               有些语言不支持逆序查找，所以可以利用捕获型括号来实现
               $popu =~ s/(\d)(?=(\d\d\d)+(?!\d))/$1,/g
               但是s/(\d)((\d\d\d)+\b)无法实现功能，它只有开始的一个逗号，即12,345678
               原因是因为\g的全局替换是从上一次匹配完成后的位置开始的，
               正向环视不消耗字符，所以一个表达式在匹配时可以加入多个逗号
               而((\d\d\d)+\b)不是匹配位置，匹配第一个逗号时即消耗了所有字符，\g无法起到预想的作用
               想使用该表达式，只有在程序中循环调用该表达式才可以，每次加入一个逗号直到无法匹配为止
        Text-to-Html转换
           处理特殊字符
            因为html中&,<,>是特殊字符，所以文本中原有的这几个字符需要进行转换成html编码才能正确显示
            $text =~ s/&/&amp;/g;
            $text =~ s/</&lt;/g;
            $text =~ s/>/&gt;/g;
           分隔段落
            perl中用undef $/; $text=<>;将多行的文本读取为一行字符串，其中每个逻辑行用\n或\r\n分割，
            由于^和$实际表示的是字符串的开头和结尾,不能按需提取每个逻辑行
            所以可以使用"增强的行锚点",即$text =~ s/^$/<p>/mg;增加了/m参数
            考虑到包括空白字符的行可以用^ *$,也可以用^\s*$,因为\s也可以匹配换行符，
            所以当有多个连续空白行时,s/^\s*$/<p>/mg只会出现一个<p>.
           Email地址转化成超链接
            $text =~ s/\b(username\@hostname)\b/<a href="mailto:$1">$1<\/a>/g;
            其中@需要转义，/a中的/需要和单词分界符区分开来，故也需要转义，perl也可以使用单词分界符{}
           用户名和主机名
            用户名可以包含字母，数字，点号和连字符，但不能以点号和连字符开头，
            所以它可以写为\w[-.\w]*
            主机名例子为www.oracle.com,.之间需要字符存在并且末尾com等需要是一些固定值
            所以它可以写为(\w+(\.\w+)*)\.(com|edu|info)
            \w可能匹配一些非ascii码字符和下划线，所以不应该用\w,应为[-a-z0-9]
            为了美化代码可以用\x修饰符，它可以忽略正则表达式中的空白符和以#号开头的注释
           综合起来
            注意只有分隔段落用到了\m，因为它用到了^和$,其他正则表达式使用了没有影响
           将http url转化为链接
               $text =~ s{
                   \b
                    # 保存url到$1中
                    (
                      http:// hostname
                      (/path)?
                    )
               }{<a href="$1"</a>}gix;
            其中单词分隔符为{},所以/a不需要转义
            path后没有\b,因为url后一般是标点符号，用逆序环视来确定标点符号前的内容能匹配到path中
            即[...]*(?<![,.!?])
           构建正则表达式库
            Email和url中的主机名hostname使用相同的正则表达式，可以使用变量将它提取出来
            即$HostnameRegex = qr/.../i;
            qr操作符能够产生一个regex对象,其他语言也提供了创建正则表达式对象的方法，比如java
           为什么$和@需要转义
            perl中字符组内部$不能正确匹配$本身，需要进行转义
            同样perl用@表示数组名，需要转义才能匹配本身
        回到单词重复问题
            $/ = ".\n"指<>返回一段文本(句号和换行符的结合),不再是单行文本
            找到重复单词用转义后的高亮文本替换重复出现的单词(这里假设原文中没有ascii转义符\e)
            转义符加好后，去除没有转义符\e的逻辑行，以上查找重复是对整个段落进行查找，这里是对
            逻辑行处理，加上\m修饰符。
            同样的，对每个逻辑行开头加上文件名($AGRV)，也是使用\m
        更深入一点: 运算符，函数和对象
            java对正则表达式的处理不像perl一样是基础级别的，它用多个包来实现
            java要求正则表达式先用字符串的形式得到一个编译版本，其中正则表达式自带的\需要转义，如\\b
            Pattern regex1 = Pattern.compile("\\b...", Pattern.CASE_INSENSITIVE);
            Pattern regex2 = Pattern.compile("^([^\\n]+)", Pattern.MULTILINE); // 表示perl中的\m修饰符
            regex1.matcher(text).replaceAll(replace1);
            regex3.matcher(text).replaceAll(args[i] + ": $1");
            即与perl的$test =~ s/../../gix中对文本应用正则表达式不同，
            java是用编译后的正则表达式对象来应用到文本中。

chapter 3 正则表达式的特性和流派概览

    1. 支持的元字符
    2. 正则表达式与语言或工具的交互方式
    3. 正则表达式引擎如何将表达式应用到文本

    正则表达式和汽车
    发展历程
        grep
        egrep
        perl 书中使用版本5.8.8 本地是5.26.2
        其中grep支持功能更少，应使用egrep,不支持非捕获型括号,单词分界符为\<\>,
        (本机用2.5.1free bsd, 经测试支持非捕获型括号,也支持\b,\<\>也支持。。。)
    正则表达式的注意事项和处理方式
        1. 句法规则 定义正则表达式，如egrep中用命令行参数引入正则表达式
        2. 对结果进行操作 如egrep显示匹配的行，包括匹配，替换，查找

        集成式处理
            $text =~ m/^Subject: (.*)/i; $subject = $1;
        程序式处理和面向对象式处理
            java中的正则处理
                import java.util.regex.*;
                Pattern regex = Pattern.compile("^Subject (.*)", Pattern.CASE_INSENSITIVE);
                Matcher m = regex.matcher(line);
                if(m.find()) {
                    subject = m.group(1);
                }
                函数式处理：Pattern.matches("\\s*", line),java会在正则表达式两边自动加上^和$
                简化了函数调用，但每次调用都会重新编译正则表达式。
            VB和.net     和java类似
            PHP     纯函数式
            if(preg_match('/^Subject: (.*)/i', $line, $matches)) {
                $Subject = $matches[1];
            }
            Python   和java类似
            差异从何而来
                开发人员的水平和思维
            查找和替换
                perl中$text =~ s{regex}{replacement}igx;查找和替换都是在目标变量text中进行的
                其他语言是在目标文本副本上进行的，需要修改原变量需要将替换结果回传。

                java中的查找和替换
                    Pattern r = Pattern.compile("
                        # 正则表达式开始            \n"+
                        "...", Pattern.CASE_INSENSITIVE|Pattern.COMMENTS);
                    Matcher m = r.matcher(text);
                    text = m.replaceAll("<a href=\"mailTo:$1\">$1</a>");
                    其中包括换行符一是格式整齐，另一方面是#注释需要以换行符结束。
                    即perl使用/g,/i,/x来表示不同的特殊条件，java用不同的函数(replaceAll)和不同标志位来限制

                vb.net中的查找和替换 和java类似
                PHP中的查找和替换 和perl类似
                其他语言中的查找和替换
                    awk,TCL,GNU Emacs
            字符串，字符编码和匹配模式
                作为正则表达式的字符串
                    即需要注意表示正则表达式的字符串处理结束后，正则引擎接受到的正则表达式是什么？
                    java中可以使用
                        Pattern regex = Pattern.compile("\\w");
                        System.out.println(regex.pattern());
                    查看真正被处理的正则表达式是什么。
                    java
                    VB.NET
                    C#
                    PHP
                    Python
                    TCL
                    Perl
                字符编码
                    编码的支持程度
                    Unicode 通常用一个4位的16进制数来表示一个字符
                    字符，还是组合字符序列
                        在unicode的编辑器中，一个带音调的字符由2个代码点组成
                    用多个代码点表示同一个字符
                        unicode中可以用2个代码点表示一个带音调的字符，也可以用一个代码点表示
                        此时，不同的字符无法从外观上区分开，需要检查生成的文本。
                    Unicode3.1后的代码点
                    Unicode中的行终止符
                    正则模式和匹配模式
                        不区分大小写的匹配模式
                            不是所有字符都有大小写形式，大小写也不一定是1对1的情况（如希腊字母）
                        宽松排列和注释模式
                            此模式会忽略字符组外部的空白字符
                            但java.util.regex中不都是忽略，而是作为一个无意义的元字符
                            如\12 3会当作3在\12后，而不是忽略空白符后的\123
                        点号通配模式
                            即.*,它常用来匹配本行中的其他内容
                        不幸的命名
                            /s表示单行文本模式，即single-line mode,但它与^和$没有关系
                            /s表示的是.号不受限制，可以匹配任何字符
                        增强的行锚点模式（也叫多行文本模式）
                            如上面的例子所示，此模式下^和$可以匹配字符串内部的换行符
                            单行模式和多行模式其实没有关系
                            单行模式改变了点号的匹配方式，换行符从需要处理变为不需要处理，即不换行
                            多行模式改变了^和$号的匹配方式，换行符从不需要处理变为需要处理，即多逻辑行
                        文字文本模式
                            该模式不识别任何正则表达式元字符，即匹配具体字符串
                    常用的元字符和特性
                        字符表示法
                            八进制转义
                            十六进制转义
                            控制字符：\cchar
                        字符组及相关结构
                            点号一般是匹配换行符之外的任意字符，点号通配模式可以改变这一规则
                            Unicode属性
                        锚点及其他零长度断言
                            即位置的匹配
                            ^和\A
                            $，\Z, \z
                            \G: java.util.regex包和Perl是匹配上一次匹配的结束位置

                                \G指向的是目标字符串的位置，可以用多个正则表达式去匹配同一个目标

                                一般匹配失败，\G的匹配会回到字符串的起始位置，可以用perl的\c修饰符
                                使它匹配失败时不会重新设定，从而可以指定某个位置开始不断匹配

                                \G的属性可以用与正则表达式无关的结构维护与修改
                        单词分界符
                            \b, \B, \<, \>
                            顺序环视和逆序环视
                                perl和python中逆序环视只能匹配固定长度的文本
                                如(?<!books?)匹配长度不确定，会报错
                                可以重写为(?<!book)(?<!books),这里用到了集合并集

                                java的regex包支持变长，(?<!books?)可以直接使用,但长度不能无限
                                如(?<!^\w+:)会报错
                                .net可以支持无限长度
                        注释和模式修饰符
                            模式修饰符
                                如(?!)和(?-i),前者表示开始不区分大小写，后者表示停止该功能。
                                一般(?!)只作用在括号内部，此时可以去掉(?-i)。如<B>(?:(?!)very)</B>.
                            模式作用范围
                                如(?i:...),此时前面的例子可以化简为<B>(?i:very)</B>.
                            文本文字范围
                                \Q...\E
                        分组，捕获，条件判断和控制
                            捕获/分组括号: (...)和\1,\2
                            非捕获型括号(?:...)
                            命名捕获(?<Name>...), python, php, .net都支持
                            固化分组: (?>...)
                                即一旦括号内的子表达式匹配之后，匹配的内容就固定下来了
                                如i.*！可以匹配iHello!，但i(?>.*)!就无法匹配iHello!，因为*不会交还一开始匹配的！,
                                从而导致匹配失败。
                            多选结构： ...|...|...  大多数流派允许出现空的多选分支
                            条件判断：(?if then |else)
                                ads



