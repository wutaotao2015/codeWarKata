
chapter 1  入门
    1. 以文件名类比
    2. 以语言做类比
        元字符和普通字符
    3. 检索文本文件 Egrep
    4. Egrep
        grep为(global search regular expression and print out the line)为文本搜索工具
        egrep用于在文件内查找指定的字符串，效果相当于grep -E，目前直接调用egrep已废弃？用grep -E
        grep是使用basic regular expression,egrep使用extended regular expression,后者更规范

        元字符
            脱字符^: 一行的开始
            美元符号$： 一行的结束
            以字符来理解正则表达式，
            如^cat表示的是以字符c开始的一行，后面紧接a和t字符
            即它们匹配的都是一个位置。
        字符组
            匹配若干字符之一
            <H[123456]>匹配<H1>,<H2>等html标签
            [0-9A-Z_!.?]匹配一个数字或大写字母，_或!或.或？,
            即在字符组[]中特殊字符只有连字符-(连字符在开头，紧接[时不是元字符,不是范围,为普通字符)
            ^cat$ 匹配只有cat的一行，不含多余字符
            ^$ 匹配一个空行 无任何字符，也不含空白字符
            ^ 匹配一行的开始，所有行都满足条件，无意义

        排除型字符组 （需要匹配一个字符，包括空白字符）
            [^1-6] 匹配除了1到6之外的任何字符，脱字符^只有紧跟[后才是元字符
            q[^u]无法匹配到Iraq
            是因为Egrep自动把换行符去掉了，若换行符没有去除，它仍是可以匹配到的
            这里说明的是排除型字符组也需要匹配一个字符
        用点号匹配任意字符 （需要匹配一个字符，包括空白字符）
            3344.55 可以匹配到 3344 55
            但33.44.55 无法匹配到 3344 55
            即点号也需要匹配到一个字符，无字符是无法匹配到的，空白字符也是一个字符
            33[-./]44[-./]55更精确，但读写消耗较大，33.44.55不够精确，但可读性和可写性强，
            在不可能匹配到非期望结果的情况下，33.44.55更佳。
            所以清楚了解目标的文本对于正确编写正则表达式是非常重要的。
        多选结构
            匹配任意子表达式
                | 表示或者(它是贪婪匹配的)，把不同的子表达式组合成一个总表达式，这个总表达式可以匹配任意一个子表达式
                子表达式称为“多选分支”
                gr[ea]y grey|gray gr(e|a)y都可以正确匹配，
                而若去掉括号gre|ay或者gr[a|e]y都不可以匹配到grey或gray的字符串
                一个字符组只能匹配目标文本中的单个字符，而多选结构可以匹配完整的正则表达式

                如(grey|gray)|(grey|gray)可以匹配到greygray和greygrey。

                ^From|Subject|Date: 和 ^(From|Subject|Date): 匹配的结果大不相同
                如果希望每个多选分支前都有脱元符和其后有冒号，需要用括号来限制这些多选分支
                egrep '^(From|Subject|Date):' test.txt
                该命令会打印出以From:或Subject:或Date:开头的一行文本
        忽略大小写
            正则表达式本身没有提供这样的功能，但egrep工具提供了，可以使用-i参数使其在匹配时忽略大小写
            grep -Ei '^(From|Subject|Date): ' test.txt
            这样也可以匹配到FROM: 了。
        单词分界符
            部分egrep支持元字符序列，即\<和\>,它与\b功能相同？
            这里说的单词的开始和结束具体指的是字母数字符号的开始和结束，除了常见的空格分隔，
            dang-wer开始于d,结束于g,再开始于w,结束于r
            we'll开始于w,结束于e,开始于l,结束于l
            $199开始于1,结束于9
        可选项元素
            colou?r这个正则表达式中？只作用于之前紧邻的元素
            4th|4可以转化为4(th)?
            此时？的作用范围扩大到整个括号了
        其他量词： 重复出现
            +代表之前紧邻的元素出现一次或多次
            *代表之前紧邻的元素出现任意多次或者不出现
            即尽可能匹配多的次数
            ' ?'能够匹配一个空格， ' *'能匹配任意多个空格
            如匹配标签的<H[1-6] *>可以匹配<H1>,<H2   >
            <HR +SIZE *= *[0-9]+ *>看起来让人迷惑，是因为元字符*和+作用的是空格，即在正则表达式中空格也是普通字符之一
            每个量词都规定了自己匹配的上下限，有的下限为0或1，有的上限为1或无穷大
        规定重现次数的范围： 区间
            如[a-zA-Z]{1,5}
        括号及反向引用
            括号用途
            1. 限制多选项的范围|
            2. 若干字符组合为一个单元，受量词？或*号等的限制
            3. 记住包含的子表达式匹配的文本。

            反向引用： 括号记住了里面匹配的文本（不是模式），后面可以通过\1,\2等来重复该文本

            如重复单词the   the可以用\<([a-zA-Z]+) +\1\>来匹配
            \1,\2,\3表示第1，2，3组括号记住的文本内容，其顺序是按左括号从左到右的顺序进行的

        神奇的转义
            slash 斜线 /
            backslash 反斜线 \   需要匹配元字符本身时可以进行转义
            此时反斜线称为转义符（escape)
            大多数语言和工具支持字符组内部的转义，不过大多数egrep命令不支持，在字符组内部\是普通字符
        基础知识拓展
            语言的差异
                每种语言提供了自己的改进，形成了自己的流派
            正则表达式的目标
            更多的例子
                变量名
                    即标识符，包含字母，数字，下划线，但不能以数字开头,不能超过32位
                    [a-zA-z_][a-zA-Z_0-9]{0，31}
                引号内的字符串
                    "[^"]*"
                美元金额 可能有小数
                    $[0-9]+(\.[0-9][0-9])?
                http/HTML url
                    \<http://[-a-z0-9_.:]+/[-a-z0-9_:@&?=+,.!/~*%$]*\.html?\>
                    或者更简单
                    \<http://[^ ]*\.html?\>
                HTML tag
                    <.*>可以匹配多个标签，如<p>short</p>
                表示时刻的文字
                    12小时制是从12，1，2，...,10, 11计数，12小时制没有数字0开头，它是从12开始
                    12：00am 即半夜0点，12：00pm是中午12点
                    即（1[012]|[1-9]):[0-5][0-9] (am|pm)
                    24小时制（0?[0-9]|1[0-9]|2[0-3]):[0-5][0-9]
                    合并前2个多选分支，变为([01]?[0-9]|2[0-3]):[0-5][0-9]
                    根据书中匹配的阴影图可以有另外一种写法 ([012]?[0-3]|[01]?[4-9])

        正则表达式术语汇总
            正则 regex
            匹配 matching
            元字符 metacharacter
                只有在字符组外部且在未转义的情况下，*才是元字符，\*中*被转义了，而\\*没有
            流派 flavor
            子表达式 subexpression
                通常是括号内的部分，也可以指|分开的部分，也指单个字符
                H[1-6] *中1-6不是子表达式，因为它属于字符组，不可分割，[1-6]是子表达式
                量词（*，+，？）作用的对象就是它之前紧邻的子表达式，或者是用括号括起来的子表达式
            字符 character
            改进现状
                正则表达式的使用
                正则表达式的特性
                正则表达式的工作原理
            总结
                元字符分类
                    匹配单个字符 . [...] [^...] \char
                    提供计数功能的元字符 ？ * + {min, max}
                    匹配位置的元字符 ^ $ \< \>
                    其他元字符 | （...) \1 \2
chapter 2 入门示例拓展
    关于这些例子
    Perl简单入门
        变量以$开头，存储数值或文本
        变量可以出现在字符串中，会被其实际值取代,可以用Perl -w test.txt命令执行脚本程序（-w参数可以检查程序是否规范）
    使用正则表达式匹配文本
        $test =~ m/^[0-9]+$/
        若测试文本test中只包含数字，则该表达式值为true
    向更实用的程序前进
        $c =~ m/^[-+]?[0-9]+(\.[0-9]*)?$/   可以匹配负数和小数
    成功匹配的副作用
        正则表达式中的在匹配时，\1反向引用了之前匹配的文本，匹配成功后接下来的程序可以用$1引用相同的文本
        $c =~ m/^([+-]?[0-9]+)([CF])$/
        其中的括号既没有改变量词的作用范围，也没有改变|的意义，即加括号不影响匹配的文本，它是括号的第3种用法，为捕获型括号。
        代码示例：

    错综复杂的正则表达式

















































