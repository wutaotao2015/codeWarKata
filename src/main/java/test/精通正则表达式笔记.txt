
chapter 1  入门
    1. 以文件名类比
    2. 以语言做类比
        元字符和普通字符
    3. 检索文本文件 Egrep
    4. Egrep
        grep为(global search regular expression and print out the line)为文本搜索工具
        egrep用于在文件内查找指定的字符串，效果相当于grep -E，目前直接调用egrep已废弃？用grep -E
        grep是使用basic regular expression,egrep使用extended regular expression,后者更规范

        元字符
            脱字符^: 一行的开始caret(脱字符，插入记号（即快捷键中的光标))
            美元符号$： 一行的结束
            以字符来理解正则表达式，
            如^cat表示的是以字符c开始的一行，后面紧接a和t字符
            即它们匹配的都是一个位置。
        字符组
            匹配若干字符之一
            <H[123456]>匹配<H1>,<H2>等html标签
            [0-9A-Z_!.?]匹配一个数字或大写字母，_或!或.或？,
            即在字符组[]中特殊字符只有连字符-(连字符在开头，紧接[时不是元字符,不是范围,为普通字符)
            ^cat$ 匹配只有cat的一行，不含多余字符
            ^$ 匹配一个空行 无任何字符，也不含空白字符
            ^ 匹配一行的开始，所有行都满足条件，无意义

        排除型字符组 （需要匹配一个字符，包括空白字符）
            [^1-6] 匹配除了1到6之外的任何字符，脱字符^只有紧跟[后才是元字符
            q[^u]无法匹配到Iraq
            是因为Egrep自动把换行符去掉了，若换行符没有去除，它仍是可以匹配到的
            这里说明的是排除型字符组也需要匹配一个字符
        用点号匹配任意字符 （需要匹配一个字符，包括空白字符）
            3344.55 可以匹配到 3344 55
            但33.44.55 无法匹配到 3344 55
            即点号也需要匹配到一个字符，无字符是无法匹配到的，空白字符也是一个字符
            33[-./]44[-./]55更精确，但读写消耗较大，33.44.55不够精确，但可读性和可写性强，
            在不可能匹配到非期望结果的情况下，33.44.55更佳。
            所以清楚了解目标的文本对于正确编写正则表达式是非常重要的。
        多选结构
            匹配任意子表达式
                | 表示或者(它是贪婪匹配的)，把不同的子表达式组合成一个总表达式，这个总表达式可以匹配任意一个子表达式
                子表达式称为“多选分支”
                gr[ea]y grey|gray gr(e|a)y都可以正确匹配，
                而若去掉括号gre|ay或者gr[a|e]y都不可以匹配到grey或gray的字符串
                一个字符组只能匹配目标文本中的单个字符，而多选结构可以匹配完整的正则表达式

                如(grey|gray)|(grey|gray)可以匹配到greygray和greygrey。

                ^From|Subject|Date: 和 ^(From|Subject|Date): 匹配的结果大不相同
                如果希望每个多选分支前都有脱元符和其后有冒号，需要用括号来限制这些多选分支
                egrep '^(From|Subject|Date):' test.txt
                该命令会打印出以From:或Subject:或Date:开头的一行文本
        忽略大小写
            正则表达式本身没有提供这样的功能，但egrep工具提供了，可以使用-i参数使其在匹配时忽略大小写
            grep -Ei '^(From|Subject|Date): ' test.txt
            这样也可以匹配到FROM: 了。
        单词分界符
            部分egrep支持元字符序列，即\<和\>,它与\b功能相同？
            这里说的单词的开始和结束具体指的是字母数字符号的开始和结束，除了常见的空格分隔，
            dang-wer开始于d,结束于g,再开始于w,结束于r
            we'll开始于w,结束于e,开始于l,结束于l
            $199开始于1,结束于9
        可选项元素
            colou?r这个正则表达式中？只作用于之前紧邻的元素
            4th|4可以转化为4(th)?
            此时？的作用范围扩大到整个括号了
        其他量词： 重复出现
            +代表之前紧邻的元素出现一次或多次
            *代表之前紧邻的元素出现任意多次或者不出现
            即尽可能匹配多的次数
            ' ?'能够匹配一个空格， ' *'能匹配任意多个空格
            如匹配标签的<H[1-6] *>可以匹配<H1>,<H2   >
            <HR +SIZE *= *[0-9]+ *>看起来让人迷惑，是因为元字符*和+作用的是空格，即在正则表达式中空格也是普通字符之一
            每个量词都规定了自己匹配的上下限，有的下限为0或1，有的上限为1或无穷大
        规定重现次数的范围： 区间
            如[a-zA-Z]{1,5}
        括号及反向引用
            括号用途
            1. 限制多选项的范围|
            2. 若干字符组合为一个单元，受量词？或*号等的限制
            3. 记住包含的子表达式匹配的文本。

            反向引用： 括号记住了里面匹配的文本（不是模式），后面可以通过\1,\2等来重复该文本

            如重复单词the   the可以用\<([a-zA-Z]+) +\1\>来匹配
            \1,\2,\3表示第1，2，3组括号记住的文本内容，其顺序是按左括号从左到右的顺序进行的

        神奇的转义
            slash 斜线 /
            backslash 反斜线 \   需要匹配元字符本身时可以进行转义
            此时反斜线称为转义符（escape)
            大多数语言和工具支持字符组内部的转义，不过大多数egrep命令不支持，在字符组内部\是普通字符
        基础知识拓展
            语言的差异
                每种语言提供了自己的改进，形成了自己的流派
            正则表达式的目标
            更多的例子
                变量名
                    即标识符，包含字母，数字，下划线，但不能以数字开头,不能超过32位
                    [a-zA-z_][a-zA-Z_0-9]{0，31}
                引号内的字符串
                    "[^"]*"
                美元金额 可能有小数
                    $[0-9]+(\.[0-9][0-9])?
                http/HTML url
                    \<http://[-a-z0-9_.:]+/[-a-z0-9_:@&?=+,.!/~*%$]*\.html?\>
                    或者更简单
                    \<http://[^ ]*\.html?\>
                HTML tag
                    <.*>可以匹配多个标签，如<p>short</p>
                表示时刻的文字
                    12小时制是从12，1，2，...,10, 11计数，12小时制没有数字0开头，它是从12开始
                    12：00am 即半夜0点，12：00pm是中午12点
                    即（1[012]|[1-9]):[0-5][0-9] (am|pm)
                    24小时制（0?[0-9]|1[0-9]|2[0-3]):[0-5][0-9]
                    合并前2个多选分支，变为([01]?[0-9]|2[0-3]):[0-5][0-9]
                    根据书中匹配的阴影图可以有另外一种写法 ([012]?[0-3]|[01]?[4-9])

        正则表达式术语汇总
            正则 regex
            匹配 matching
            元字符 metacharacter
                只有在字符组外部且在未转义的情况下，*才是元字符，\*中*被转义了，而\\*没有
            流派 flavor
            子表达式 subexpression
                通常是括号内的部分，也可以指|分开的部分，也指单个字符
                H[1-6] *中1-6不是子表达式，因为它属于字符组，不可分割，[1-6]是子表达式
                量词（*，+，？）作用的对象就是它之前紧邻的子表达式，或者是用括号括起来的子表达式
            字符 character
            改进现状
                正则表达式的使用
                正则表达式的特性
                正则表达式的工作原理
            总结
                元字符分类
                    匹配单个字符 . [...] [^...] \char
                    提供计数功能的元字符 ？ * + {min, max}
                    匹配位置的元字符 ^ $ \< \>
                    其他元字符 | （...) \1 \2
chapter 2 入门示例拓展
    关于这些例子
    Perl简单入门
        变量以$开头，存储数值或文本
        变量可以出现在字符串中，会被其实际值取代,可以用Perl -w test.txt命令执行脚本程序（-w参数可以检查程序是否规范）
    使用正则表达式匹配文本
        $test =~ m/^[0-9]+$/
        若测试文本test中只包含数字，则该表达式值为true
    向更实用的程序前进
        $c =~ m/^[-+]?[0-9]+(\.[0-9]*)?$/   可以匹配负数和小数
    成功匹配的副作用
        正则表达式中的在匹配时，\1反向引用了之前匹配的文本，匹配成功后接下来的程序可以用$1引用相同的文本
        $c =~ m/^([+-]?[0-9]+)([CF])$/
        其中的括号既没有改变量词的作用范围，也没有改变|的意义，即加括号不影响匹配的文本，它是括号的第3种用法，为捕获型括号。
        代码示例：
        if($input =~ m/^([+-]?[0-9]+)([CF])$/){
	        $num = $1;
	        $type = $2;
	        if ($type eq "C") {
    错综复杂的正则表达式
        允许输入浮点数时，正则表达式变为 ^([-+]?[0-9]+(\.[0-9]*)?)[ \t]*([CF])$
        此时程序中区分摄氏度和华氏度的C和F的保存变量由$2变为$3
        如果不想更改程序中的$2,即这个小数部分程序中不需要用到的话，可以使用非捕获型括号（?:...）
        即只分组不捕获
        此时正则表达式变为^([-+]?[0-9]+(?:\.[0-9]*)?)[ \t]*([CF])$
        这时CF保存的变量（Perl中）即为$2,小数部分(?:)不影响捕获计数
        非捕获型括号可以提高匹配效率，使得括号区分度高，但提高了阅读难度，可以根据具体情况选择是否使用

        [ \t]*和（ *|\t*)的区别
            后者不能匹配空格和\t的混合，只能匹配多个空格或者多个制表符
            前者*限制的是字符组[ \t],所以每个字符都可以进行选择，即支持匹配两者混合的情况

    一点题外话——数量丰富的元字符

        字符串的元字符和正则表达式的元字符是不同的，它们有的是相同的意义，如制表符\t
        shell中的空格符，$, *, ?等也是其自身的元字符，需要与正则表达式区分开
        即有的时候需要在不同层级上同时使用元字符进行交互

        用\s匹配所有空白
            即相比[ \t]*,使用\s是更好的选择
            \s表示所有空白字符的字符组，包括了空格符，制表符，换行符，回车符
            用m/.../i可以匹配大小写，其他还有/g表示全局匹配
            程序中的$type eq "C"需要修改为 $type =~ m/c/i同时匹配大小写的c
            所以正则表达式的变化也会影响到程序的其他部分
        暂停片刻
            Perl的正则表达式中的元字符比egrep更多，java, python类似于Perl
            Perl和其他流派的正则表达式提供了很多简记法shorthands:
                \t \n \r \s \S
                \w = [a-zA-Z0-9] \w+即一个单词
                \W = [^a-zA-Z0-9]
                \d = [0-9]
                \D = [^0-9]
            匹配成功后，Perl可以用$1, $2等变量保存对应括号内子表达式匹配到的文本，
            使用这些变量就可以用正则表达式从字符串中提取我们所需要的信息
    使用正则表达式修改文本
        使用$var =~ s/.../.../ 即如果正则表达式能够匹配$var中的某段文本，就将这段匹配上的文本替换为后面的文本
        如
         $test = "HelloTest666Test";
         $test =~ s/Test\d+Test/999/;
         print "$test\n"
        输出结果为Hello999

        $var =~ s/\bJeff\b/Jeff/i
        其中/i限制的是对\bJeff\b中的Jeff的大小写情况，即不论Jeff的大小写情况如何，它会被统一替换为Jeff

        例子：公函生成程序
        s/regex/replacement/中的用于替换的replacement其实是perl中的字符串，
        可以像上面的程序那样引用变量
        \g全局替换修饰符，即第一次替换完成后继续搜索更多匹配文本，进行更多替换

        例子：修整股票价格
            23.423000000234小数点后第3位若不为0就保留3位，否则就保留2位，
            思路即对整个数字进行匹配，将需要保留的部分放入括号内，替换时利用括号捕获进行替换
            第3位利用[1-9]?)\d*来进行取舍
            $price =~ s/(\.\d\d[1-9]?)\d*/$1/
            小数点后面的\d*被正则表达式匹配上了，用$1替换时会被删除
        自动的编辑操作
            perl -p -i -e 's/X/wutaotao/g' 2test.txt
            -p 对每行进行查找和替换 和-n相似，循环
            -i 将替换结果写入文件 edit files in place
            -e 后面接的就是程序本身，省略了文件 one line program
            即通过一行命令可以替换多个文件中的多个字符
        处理邮件的小工具
            $line = <> 这条语句相当于getLine(),读入一行数据,为空时返回false
            如上面匹配html标签一样，<.*>中会匹配尽可能多的任意字符，使用时应注意前后端的表达式匹配的重复性问题
            针对发送地址的提取，如From: taotao@qq.com (wutaotao)需要提取其中的邮件地址和后面括号中的姓名
            ^From: (\S+) \(([^()]*)\)
            其中\S表示非空白字符，[^()]表示非括号的排除型字符组，值得注意的是在字符组内部括号不是元字符，不需要转义

            perl中while的break为关键字last
            在每行开头增加|> 可以用正则表达式
            while($line = < >) {
                   $line =~ s/^/|> /;
                   print $line;
            }
            由此可以得到类似的有效例子：
                perl -p -i -e 's/^/**/' 3Test.txt 开头增加2个星
                perl -p -i -e 's/^\*+(.*)$/$1/' 3Test.txt 去掉开头增加的星
        用环视功能为数值添加逗号（分位符）
            环视不匹配字符，只匹配位置，同^,$,\b相似
            顺序环视
                顺序查看文本（向右找），如果匹配子表达式，则匹配成功
                (?=...)
            逆序环视
                逆序查看文本（向左找），同样不消耗字符
            环视不会消耗字符（占用）
                环视可以精确定位到需要匹配的位置
                (?=Jeffery)Jeff与Jeff(?=ery)是等价的，最终匹配点位置停在了Jeffery的ff后。
                即前面的环视匹配成功后可以定位到Jeffery的前方，再进行匹配Jeff字符
                若环视匹配不成功，整个正则表达式也不会匹配成功
                如Jeff(?=Jeffery)就不能匹配上

                (?=) (?<=) (?:)都是有自己的"开括号"--(?, 没有普通括号的捕获功能。
            更多的环视例子
                如将see Jeffs book中Jeffs改为Jeff's
                应用环视的终极例子为
                    perl -p -i -e "s/(?<=\bJeff)(?=s\b)/'/g" 4test.txt
                    这个例子说明了（？=）是从目标位置的右边开始寻找，（?<=)是目标位置的左边开始寻找，
                    即一个是右边，一个是左边，具体的匹配过程仍然是从左到右的
                    两个位置限制都符合的情况下，该位置就被确定了
                    perl -p -i -e "s/(?=s\b)(?<=\bJeff)/'/g" 4test.txt
                    环视结构的顺序是无所谓的，因为它们都未消耗字符，同时满足就可以。
                    （最后加\i有问题）
            回到逗号的例子
                $popu = 12345678;
                $pop =~ s/(?<=\d)(?=(\d\d\d)+$)/,/g;
                print $pop;
                程序中的$保证了逗号后面的数字个数是3的倍数, 要插入逗号的位置前至少有一个数字
                其中（\d\d\d)是捕获型括号，会保存值到$1中，可以替换为(?:\d\d\d),不过可读性降低了
            单词分界符和否定环视
               $popu = "12345678 is growing"时$无法使用，因为数字后面还有内容，不是行尾
	       所以可以用单词分界符\b代替
	       否定环视
	         正向肯定环视(positive lookahead) (?=)
		 反向肯定环视(positive lookbehind) (?<=)
		 正向否定环视(negative lookahead) (?!)
		 反向否定环视(negative lookbehind) (?<!)
		 所以单词分界符\b = (?<=\w)(?!\w)|(?<!\w)(?=\w)
		 所以上述例子应写为$popu =~ s/(?<=\d)(?=(\d\d\d)+(?!\d))/,/g;
		 \D代表某个不是数字的字符，它和(?!\d)不同,后者可以匹配空，前者必须要有一个字符
	    不通过逆序环视添加逗号
	       有些语言不支持逆序查找，所以可以利用捕获型括号来实现
	       $popu =~ s/(\d)(?=(\d\d\d)+(?!\d))/$1,/g
	       但是s/(\d)((\d\d\d)+\b)无法实现功能，它只有开始的一个逗号，即12,345678
	       原因是因为\g的全局替换是从上一次匹配完成后的位置开始的，
	       正向环视不消耗字符，所以一个表达式在匹配时可以加入多个逗号
	       而((\d\d\d)+\b)不是匹配位置，匹配第一个逗号时即消耗了所有字符，\g无法起到预想的作用
	       想使用该表达式，只有在程序中循环调用该表达式才可以，每次加入一个逗号直到无法匹配为止

chapter 3 test
  3.1 test
    sdfsdf
